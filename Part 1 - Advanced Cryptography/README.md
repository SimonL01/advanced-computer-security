# Synthesis
**INFO8013 - Advanced Computer Security**

*Teaching Staff* : 
Beno√Æt Donnet
Laurent Mathy

*Teaching Assisstant* :
Vincent Jacquot

# Table of Contents

1. [Part 1 : Advanced Cryptography](#part-1-advanced-cryptography)
    1. [Chapter 1 : Advanced Digital Signatures](#chapter-1-advanced-digital-signatures)
        1. [Overview](#overview)
        2. [RSA Signature](#rsa-signature)
        3. [ElGamal Signature](#elgamal-signature)
        4. [DSA Signature](#dsa-signature)
        5. [Applications](#applications)
    2. [Chapter 2 : Bank Card Payment](#chapter-2-bank-card-payment)
        1. [History of Payment](#history-of-payment)
        2. [Bank Card Architecture](#bank-card-architecture)
        3. [Basic Payment Protocol](#basic-payment-protocol)
        4. [Europay MasterCard And Visa](#europay-mastercard-and-visa)
        5. [Contactless Payment](#contactless-payment)
    3. [Chapter 3 : Merkle Tree](#chapter-3-merkle-tree)
        1. [Problem](#problem)
        2. [Principle](#principle)
        3. [Use Cases](#use-cases)
    4. [Chapter 4 : Blockchains](#chapter-4-blockchains)
        1. [Overview](#overview-blockchain)
        2. [Block](#block)
        3. [Use Cases](#use-cases-blockchain)
    5. [Chapter 5 : Securing Bitcoin](#chapter-5-securing-bitcoin)
        1. [High Level Overview](#high-level-overview)
        2. [Transactions](#transactions)
        3. [Bitcoin Address](#bitcoin-address)
        4. [Transaction Validity](#transactions-validity)
    6. [Chapter 6 : Smart Contracts](#chapter-6-smart-contracts)
        1. [Principle](#principle-smart-contract)
        2. [Ethereum](#ethereum)
        3. [Solidity](#solidity)
        4. [Attacks](#attacks)

## Part 1 Advanced Cryptography

### Chapter 1 Advanced Digital Signatures

#### Overview

**Physical Signature**

Goal : Bind document to author
Problem : In the digital world, anyone can copy anyone's signature from one document to another.

**Digital Signature**

Solution : Make the signature depend on document

![Local Image](/images/chapter1/1.PNG)

**Model Syntax**

* A <ins>**signature scheme**</ins> $(Gen, S, V)$ is a triplet of algorithms
    - $Gen()$ : the key generation algorithm
        * outputs a key pair $(p_{k}, s_{k})$ made of the public key $p_{k}$ and private key $s_{k}$
    - $S(s_{k}, m \in M)$ : the signing algorithm
        * it takes the private key $s_{k}$ and a message $m$ from the message space $M$
        * outputs signature $\sigma$
    - $V(p_{k}, m, \sigma)$ : the verification algorithm
        * it takes the public key $p_{k}$, a message $m$ and a signature $\sigma$
        * outputs `Accept` or `Reject`

* Consistency : ensuring that the signature scheme works correctly
    - $\forall$ $(p_{k}, s_{k})$ generated by $Gen()$
        * $\forall$ m $\in$ $M$, $V(p_{k}, m, S(s_{k}, m))$ = `Accept`
        * This means that if you sign the message with the private key to get the corresponiding signature, then verifying the message and the signature with the public key should output `Accept`

**Security Model**

* Forgery
    - If Jack can create a valid digital signature for a message $(m, \sigma)$
    - Such that $V(p_{k}, m, \sigma)$ = `Accept`
    - For a message not previously signed by Alice
    - The pair $(m, \sigma)$ forms a forgery
* Goals of an attacker
    1. <ins>**total break**</ins>
        * Jack can determine Alice's private key
        * Jack can generate any number of signed message. This means that Jack can sign any message on behalf of Alice, generating an unlimited number of valid signatires. It completely compromises the **integrity** of Alice's communication.
    2. <ins>**selective forgery**</ins>
        * Given a message $m$, Jack can determine $\sigma$ such that $(m, \sigma)$ is valid for Alice
        * Jack is able to forge a signature for a specific, pre-chosen message. This requires Jack to have some knowledge or control over the message $m$ he wants to forge.
    3. <ins>**existential forgery**</ins>
        * Jack is able to create $\sigma$ for some $m$, such that $(m, \sigma)$ is valid for Alice
        * Jack can forge a signature for at least one message, though he doesn't control what the message is.
* Assumptions
    1. <ins>**key-only attack**</ins>
        * Jack only has Alice's $p_{k}$ and access to $V()$
    2. <ins>**known-message attack**</ins>
        * Jack owns a list of messages signed by Alice
        * $(m_{1}, \sigma_{1}), (m_{2}, \sigma_{2})$, ..., $(m_{n}, \sigma_{n})$
    3. <ins>**selected-message attack**</ins>
        * Jack selects messages $m_{1}, m_{2}, ..., m_{n}$
        * Jack tricks Alice into providing the corresponding signatures $\sigma_{1}, \sigma_{2}, ..., \sigma{n}$
        * Under this assumption where the attacker has a lot of power, if the scheme is secure, it is considered very robust.

#### RSA Signature

**Basic Signature Principle**

![Local Image](/images/chapter1/2.PNG)

* Signing Process (S)
    1. Inputs
        - Private key $(s_{k})$ : this is the secret key knwon only to the assigner (Alice in this case)
        - Message $(m)$ : the message that Alice wants to sign
        - Parameter (n) : a modulus used in the computation, which is part of the public parameters of the system
    2. Signature Generation
        - The signature $\sigma$ is computed using the formula : $$\sigma = m^{s_{k}} \; mod \; n$$
        - This means that the message $m$ is raised to the power of the private key $s_{k}$, and then the result is taken modulo n
    3. Output
        - The signed message and the signature pair $(m, \sigma)$ are returned
* Verification Process (V)
    1. Inputs
        - Public key $(p_{k})$ : This is the public key corresponding to the private key $(s_{k})$. It is known to everyone, including the verifier (Bob in this case).
        - Message $(m)$ : The message that was originally signed.
        - Signature $(\sigma)$ : The signature that needs to be verified
        - Parameter $(n)$ : The same modulus used during the signing process
    2. Signature Verification
        - The verifier checks if the message $m$ is equal to $$\sigma^{p_{k}} \; mod \; n$$
        - This involves raising the signatire $\sigma$ to the power of the public key $p_{k}$ and then taking the result modulo n.
    3. Output
        - If the computed value matches the original message $m$, the verifier returns `Accept`, indicating that the signature is valid.
        - If the computed value does not match $m$, the verifier returns `Reject`, indicating that the signature is invalid.
* Explanation
    - This signature scheme relies on the mathematical properties of modular arithmetic and exponentiation. The private key $s_{k}$ is used to create a signature, while the public key $p_{k}$ is used to verify the signature. The security of this scheme depends on the difficulty of reversing the exponentiation operation without knowing the private key $s_{k}$.
    - Asymmetry : The private key is used for signing, and the corresponding public key is used for verification. This asymmetry ensures that only the holder of the private key (Alice) can create a valid signature, but anyone with the public key (Bob) can verify it.
    - Integrity and Authenticity : By verifying that $m = \sigma^{p_{k}} \; mod \; n$, Bob ensures that the message has not been altered and that it was indeed signed by Alice.
    - Non-repudiation : Once Alice has signed the message, she cannot deny having signed it because the signature can only be generated using her private key.

**Signature Forgery**

RSA is sensitive to a selected ciphered text attack : by carefully choosing two or more ciphertexts and using the multiplicative property, an attacker could forge a signature. For instance, if an attacker wants to forge a signature for a message $m$ without knowing the private key, they could try to find two messages $m_{1}$ and $m_{2}$ for which they already have signatures such that $m_{1} = m_{2} = m \; mod \; n$. Then, by multiplying the signatures, they would end up with a valid signature for $m$.

![Local Image](/images/chapter1/3.PNG)

In this example, the attacker (represented by the pirate) attempts to forge a sgnature using only the public key. This is an existential forgery attack under key-only conditions.

Here it demonstrates a simplified example of how an attacker can forge a digital signature using only yhe public key, highlighting the importance of designing signature schemes that can resist such attacks to ensure the integrity and authenticity of signed messages.

* First Forgery :
    - Key-Only Attack : The attacker only needs the public key $p_{k}$ and parameter $n$, making this attack feasible without access to the private key or previously signed messages.
    - Existential Forgery : The attacker is able to generate a valid signature for some message $m$ without controlling or choosing the specific message. This demonstrates a vulnerability where the attacker can produce at least one valid message-signature pair.

Recalll that **Integrity** ensures that the data has not been altered or tampered with during transmission or storage. When a message is signed with a digital signature, the integrity of the message can be verified by checking that the message has not changed since it was signed. The verification process involves checking that the received message $m$ corresponds to the signature $\sigma$ when using the public key $p_{k}$. If the message has been altered, the verification will fail. In other words, Integrity protects against accidental or malicious changes to the data. \
On the other hand, **Authenticity** ensures that the data comes from a legitimate and verified source, confirming the identity of the sender. A digital signature provides a way to verify that the message was indeed created by the claimed sender (Alice in this case). The verification process involves using Alice's public key $p_{k}$ to validate the signature $\sigma$ on the message $m$. Since only Alice's private key $s_{k}$ could have generated the signature, a successful verification confirms that Alice is the sender. Authenticity prevents impersonation and verifies the origin of the data, its identity.

* <ins>**Multiplicative Property**</ins> of RSA
    - the product of 2 cipher texts is equal to the encryption of the product of the respective plain texts
    - $e_{p_{k}} \times e_{p_{k}} \equiv e_{p_{k}}(m_{1} \times m_{2}) \; mod \; n$
    - RSA is sensitive to a selected ciphered text attack.

The algorithm **RSA (Rivest-Shamir-Adleman)** is sensitive to a chosen ciphertext attack (CCA) because of the mathematical properties of the RSA algorithm and the lack of inherent mechanisms in basic RSA to prevent such attacks.

RSA is a public-key cryptosystem that involves two keys : a public key (used for encryption) and a private key (used for decryption). The public key consists of $(e , n)$ and the private key consists of $(d, n)$, where $n$ is a large composite number (product of two primes), $e$ is the encryption exponent, and $d$ is the decryption exponent.

In a chosen ciphertext attack, an attacker can choose ciphertexts and obtain their corresponding plaintexts through some means, such as querying a decryption oracle (an entity that decrypts given ciphertexts).

Why is RSA sensitive to CCA ?
1. Mathematical Structure
    * The RSA algorithm is deterministic and algebraic, meaning that the encryption of a given plaintext always produces the same cyphertext and the decryption of a given ciphertext always produces the same plaintext. This makes it easier for attackers to exploit the structure.
2. Multiplicative Property
    * RSA has a property that makes it particularly vulnerable to CCA. Specially, if $c = m^{e} \; mod \; n$ is a ciphertext, then for any value $k$, the ciphertext $c' = (k^{e} \; . \; c) \; mod \; n\$ is the encryption of the plaintext $(k \; . \; m) \; mod \; n$
    * This property can be exploited by an attacker to learn information about the plaintext

Example of a Chosen Ciphertext Attack on RSA :
1. Original Ciphertext
    - An attacker intercepts a ciphertext $c$ that they want to decrypt to obtain the plaintext $m$.
2. Modify Ciphertext
    - The attacker selects a random value k and computes a new cyphertext $c' = (k^{e} \; . \; c) \; mod \; n$
3. Oracle Query
    - The attacker sends $c'$ to a decryption oracle and obtains the plaintext $m' = (k \; . \; m) \; mod \; n$
4. Recover Original Plaintext
    - Since $m' = (k \; . \; m) \; mod \; n$, the attacker can compute the original plaintext $m$ by computing $m' k^{-1} \; mod \; n$

**RSA** can be used both for **Encryption/Decryption** and for **Digital Signatures**, but the role of the public and private keys are different in each use case.
1. RSA for Encyption/Decryption (Confidentiality)
    - Encryption 
        * The sender uses the recipient's public key $(e, n)$ to encrypt the message
        * The ciphertext $c$ is generated using the formula $c = m^{e} \; mod \; n$
    - Decryption
        * The recipient uses their private key $(d, n)$ to decrypt the ciphertext
        * The plaintext $m$ is recovered using the formula $m = c^{d} \; mod \; n$
    - Purpose
        * To ensure that only the intended recipient, who possesses the private key, can decrypt and read the message.
2. RSA for Digital Signatures (Authenticity and Integrity)
    - Signing
        * The sender (signer) uses their private key $(d, n)$ to create a digital signature
        * The signature $\sigma$ is generated using the formula : $\sigma = m^{d} \; mod \; n$, where $m$ is hash of the message (to ensure a fixed size and security properties)
    - Verification
        * The recipient uses the sender's public key $(e, n)$ to verify the signature
        * The recipient checks the signature by computing : $m' = \sigma^{e} \; mod \; n$ and comparing $m'$ to the expected hash of the message
    - Purpose
        * To ensure that the message was indeed signed by the sender and has not been altered (integrity), and to verify the identify of the sender (authenticity)
3. Key Role Difference
    - Public Key
        * Encryption/Decryption : Used by the sender to encrypt messages
        * Digital Signatures : Used by the recipient to verify the sender's signature
    - Private Key
        * Encryption/Decryption : Used by the recipient to decrypt messages.
        * Digital Signatures : Used by the sender to sign messages
4. Summary of Differences
    - Encryption
        * The public key encrypts, and the private key decrypts
    - Digital Signatures
        * The private key signs, and the public key verifies
5. Example to Illustrate Both Uses
    - Encryption/Decryption
        * Alice wants to send a confidential message to Bob
        * Alice encrypts the message using Bob's public key
        * Bob decrypts the message using his private key
    - Digital Signature
        * Alice wants to send a signed message to Bob
        * Alice signs the message using her private key
        * Bob verifies the signature using Alice's public key

* Second Forgery
    - Known message
    - Existential forgery

* Suppose Alice creates signatures for two messages $m_{1}$ and $m_{2}$.
    - $(m_{1}, \sigma_{1}) = S(s_{k}, m_{1}, n)$
    - $(m_{2}, \sigma_{2}) = S(s_{k}, m_{2}, n)$

* Jack can use the multiplicity property of RSA to create a forgery
    - $(m_{1} \times m_{2} \; mod \; n, \sigma_{1} \times \sigma_{2} \; mod \; n)$ is a forgery
    - $\sigma_{1} \times \sigma_{2} \equiv m_{1}^{s_{k}} \times m_{2}^{s_{k}} \; mod \; n$

**Extended Signature Principle**

![Local Image](/images/chapter1/4.PNG)

* One may incorporate a hash functions in the scheme to prevent forgery.
* How does the hash function help ?
    - It prevents the 1st forgery
        * forgery becomes equivalent to preimage attack on hash functions (given $y$, it is difficult to find $x$, such that $H(x) = y$)
        * Recall that a preimage attack involves finding the input $x$ such that the hash functions $H(x)$ produces a given hash value $y$.
        * This converts forgery into the difficult problem of finding preimages in a hash function
    - It prevents the 2nd forgery
        * $\sigma_{1} \times \sigma_{2} \equiv H(m_{1})^{s_{k}} \times H(m_{2})^{s_{k}} \; mod \; n \; ! \equiv m_{1}^{s_{k}} \times m_{2}^{s_{k}} \; mod \; n$
        * such a forgery is (very) unlikely
        * This ensures the multiplicative properties of RSA signatures do not translate to forgery of combined messages.
    - It also prevents 2nd preimage problem
        * given $x$, it is difficult to find $x' \neq x$, such that $H(x) = H(x')$
        * This ensures that it is computationally infeasible to find another message $m'$ that produces the same hash as the original message $m$, hence preventing signature forgery by message collision.
        * given $(m, \sigma)$, it is difficult to find $(m', \sigma)$

#### ElGamal Signature

**Discrete Logarithm**

* Logarithms are the inverse of exponentiation
    - $b^{y} = x \equiv log_{b}(x) = y$

* Let us now consider arithmetic mod $p$, where $p$ is prime

* The <ins>**discrete logarithm**</ins> to the base $b$ of $x$ is an integer $y$ such that
    - $b^{y} mod \; p = x$
    - notation : $dlog_{b}(x) = y$

* Example
    - let $p = 17$
    - $3^{4} mod 17 = 81 \; mod \; 17 = 13$
    - $3^{4} = 13 mod 17$
    - $dlog_{3}(13) = 4$

* Example
    - fix a prime $p$, such that $p > 2$
    - $g \in \Z^{*}_{p}$
        * $\Z^{*}_{p} = \Z^{p} \setminus \{0\}$
        * $Z_{p}$ is the residue class modulo $p$
            - all integers (negatives and positives) that are congruent modulo $p$ in the set $\{0, 1, ..., p-1\}$
    - consider the function
        * $f(x) = g^{x} in \Z_{p}$
    - now consider the inverse function
        * $dlog_{g}(g^{x}) = x, x \in \{0, ..., p-2\}$

* **Link to Python File**
    - **[compute.py](compute.py)**

* Application to cryptography ?
    - given $b$, $y$, and $p$, compute $b^{y}$ mod $p$
        * pretty much easy
        * right-to-left binary algorithm
    - given $b$, $p$, and $x$, compute y such that $b^{y}$ mod $p = x$
        * pretty much hard

* The discrete logarithm problem is a candidate one way function

**Signature Principle**

* <ins>**ElGamal Signature**</ins> is based on the discrete log problem
* Variant has been adopted by NIST as the DSA

![Local Image](/images/chapter1/5.PNG)

![Local Image](/images/chapter1/6.PNG)

* Generally, $p$ is a prime of length 1,024 bits and the signature $\sigma = (\gamma, \delta)$ is of 2,048 bits. If length matters, Schnorr's signature scheme is a modification of ElGamal such that the signature has length around 320 bits.

* The ElGamal signature scheme relies on the discrete logarithm problem, which is computationally infeasible to solve efficiently. This means that knowing the value of $\alpha^{k} \; mod \; p$ does not help in determining $k$ when $p$ is large. The security depends on the difficulty to compute $k$.

* Advantage : no known efficient solution for the discrete logarithm problem

* Disadvantage : each signature requires a random $k$ which can be challenging as $k$ cannot be reused or compromised

* The public key is bound to the private key because its component $\alpha$ and $\beta$ are in a relationship such that $\beta = \alpha^{s_{k}}$. So only someone that knows $s_{k}$ can create a valid signature. Deriving $s_{k}$ from $p_{k}$ is as difficult as solving the discrete logarithm problem.

![Local Image](/images/chapter1/7.PNG)

**Signature Forgery**

1. Security Against Selective Forgery
    - Given $m$, an attacker needs to find $(\gamma, \delta)$ such that $V(m, (\gamma, \delta), p)$ = `Accept`
    - Attempt 1 :
        * Choose $\gamma$, try to compute $\delta$ such that $\beta^{\gamma} \gamma^{\delta} \equiv \alpha^{m} \; mod \; p$
        * $\delta = log_{\gamma}\alpha^{m}\beta^{-\gamma}$
        * This is the intractable discrete logarithm problem
    - Attempt 2 :
        * Choose $\delta$, try to compute $\gamma$ such that $\beta^{\gamma} \gamma^{\delta} \equiv \alpha^{m} \; mod \; p$
        * No solution for that
    - Attempt 3 :
        * Choose $\gamma$ and $\delta$ such that $\beta^{\gamma} \gamma^{\delta} \equiv \alpha^{m} \; mod \; p$
        * No way known
2. Security Against Existential Forgery
    - An attacker needs to find an $(m, (\gamma, \delta))$ such that $V(m, (\gamma, \delta))$ = `Accept`
    - The <ins>**One-Parameter Forgery**</ins>
        * D. Pointcheval, J. Stern.  Security Proofs for Signature Schemes.  In Proc. EUROCRYPT.  May 1996
    
        ![Local Image](/images/chapter1/8.PNG)

    - The <ins>**Two-Parameter Forgery**</ins>
        ![Local Image](/images/chapter1/9.PNG)
    - The <ins>**Two-Parameter Forgery**</ins>
        ![Local Image](/images/chapter1/9.PNG)
    
    - The <ins>**Two-Parameter Forgery**</ins>
        
        ![Local Image](/images/chapter1/9.PNG)

3. Of course, hashing the message prevents forgeries, same as extended RSA signature.

**Improper Use**

* What if $k$ is not a secret ?
    - $gcd(\gamma, p-1) = 1$ then
        * secret $s_{k} = (m - k \times \delta) \times \gamma^{-1} \; mod \; (p-1)$
    - The secret key $s_{k}$ is retrieved
        * Jack can create many forgeries

![Local Image](/images/chapter1/10.PNG)

![Local Image](/images/chapter1/11.PNG)

#### DSA Signature

**Signature Principle**

* Based on discrete log problem, similar to ElGamal and Schnorr, it was adopted by NIST in the 90's

![Local Image](/images/chapter1/12.PNG)

![Local Image](/images/chapter1/13.PNG)

**Signature Forgery**

* DSA is designed based on the principle of modular exponentiations and discrete logarithms being computationally hard to reverse. The algorithm uses modulo arithmetic in a finite field to ensure that the verification process can confirm the authenticity of a signature without revealing the secret key.

* Advantage : Smaller key sizes compared to RSA for similar level of security

* Disadvantage : 
    - Slower than RSA for signing if larger key sizes
    - Sensitive to proper choice of k (copromised or reused)
    - Not an encryption algorithm but a signing algorithm so it cannot establish a secret key between parties

* $s_{k}$ is chosen to be smaller than $q$ and $p_{k}$ derived from $s_{k}$ as $\beta \equiv \alpha^{s_{k}} \; mod \; p$. SO the security of DSA relies on the difficulty of computing discrete logarithm in the subgroup generated by $\alpha$ of order $q$, which is why it is crucial that $\alpha$ is of order $q$ and that $q$ is a large prime number. This is the intractability of certain mathematic problems meaning that the difficulty of solving such problems within reasonable amount of time and feasible amount of computational resources is what makes them intractable.

* There are 2 ways to attack DSA (attempt to recover the secret key)
    - Target the large cyclic group $\Z_{p}$
        * Technique such as <ins>**index calculus**</ins>
        * For a 1024 bits $p$, security of 80 bits (calculate $p$ as if 80 bits)
        * [Handbook of Applied Cryptography : Chap 3](http://cacr.uwaterloo.ca/hac/about/chap3.pdf)
    - Target the smaller group $\Z_{p}$
        * Relies on <ins>**Pollar-rho**</ins> algorithm for solving the discrete logarithm problem
        * For a 160 bits $q$, security of 80 bits

#### Applications

**Code Signing**

* Principle of code signing (ensuring authenticity and integrity of software ):
    - Software vendor signs code with its private key
    - Clients have vendor's $p_{k}$ and install software if signature verifies (because the software might be distributed on an untrusted website for example)

    ![Local Image](/images/chapter1/14.PNG)

* More generally :
    - One-Time Authenticated Channel
        * The initial communication between the vendor and the client occurs over an authenticated, but non-private, one-directional channel. This channel is used to establish the client's trust in the vendor's public key.
        * Non-private as it doesn't require to be confidential but it must be authenticated to prevent tampering.
        * One-directional as the communication flows from the vendor to the client.
    - Initial Software Install
        * The initial software installation is authenticated via the public key exchanged over the one-time authenticated channel. This ensures the software is from the legitimate vendor but does not necessarily protect the confidentiality of the software.
    - Subsequent Updates
        * The channel is used in a one-directional manner from the vendor to the client for subsequent updates.
    - Vendor
        * generates the key pair
        * sends the public key over the one-time authenticated channel
        * signs each update $up_{i}$ to produce the signature $\sigma_{i}$
        * sends signatures and updates
    - Client
        * receives vendor's public key
        * verifies and installs updates with $V(up_{i}, \sigma_{i}, p_{k})$, if successfful, installs software
        
        ![Local Image](/images/chapter1/15.PNG)

**EMV**

* <ins>**Europay Mastercard Visa**</ins>
    - International security standard for smart payment cards
    - Greatly simplified :

    ![Local Image](/images/chapter1/16.PNG)

    - Transaction Details Sent to Card
        * The POS terminal sends the transaction details to the EMV card. This includes 
            - Nonce : A random number used once to ensure the transaction's uniqueness
            - PIN : The cardholder's Personal Identification Number, if required
    - Card Generates Signature
        * Using its private key, the EMV card signs the transaction details, producing a digital signature that ensures the authenticity and integrity of the transaction
    - Card Sends Signature and Certificate to Terminal
        * The EMV card sends back the signed transaction details and its card certificate to the POS terminal. The card certificate contains the card's public key and is signed by the card issuer. The cardholder cannot deny the transaction as the card's private key uniquely signs it.
    - Terminal Verifies Signature
        * The POS terminal uses the card's public key (retrieved from the card certificate) to verify the signature. If the signature is valid, it means the transaction details were not tampered witn and indeed from the card.
        * Transaction proceeds and ther POS terminal may send the transaction details to the bank for further processing.

**Certificates**

* This explains how certificates work in the context of setting up secure communications over the internet, focusing on the role of a trusted third party known as a **Certificate Authority (CA)**.

* Problem :
    - A browser (or any client) needs the public key $p_{k}$ of a server to establish a secure session key. However, the browser needs to ensure that the public key actually belongs to the intended server (e.g., Gmail) and not to an imposter.
* Solution :
    - The server (Gmail) asks a trusted third party, a **Certificate Authority (CA)**, to sign its public key. This process involves creating a digital certificate that attests to the authenticity of the server's public.

* When a browser connects to Gmail, Gmail sends the signed certificate to the browser. The browser uses the CA's public key $(p_{k_{CA}})$ to verify the CA's signature on the certificate. If the verification is successful, the browser can trust that the public key in the certificate belongs to Gmail. The browser <ins>**trusts**</ins> the CA to verify the identify of the server, which in turn allows the browser to <ins>**trust**</ins> the server's public key.

![Local Image](/images/chapter1/17.PNG)

**DKIM**

* <ins>**DKIM (Domain Key Identified Mail)**</ins> is a protocol used to authenticate email messages to prevent spoofing and ensure email integrity.

* Problem :
    - Email Spoofing : A malicious actor can send an email that appears to be from a legitimate domain but is actually from a fraudulent domain.
    - Damage to Reputation : This makes it seem like legitimate domains are sources of spam or malicious emails, damaging their reputation
* Solution :
    - Signing Emails : The legitimate domain signs every outgoing email with a private key. This signature allows recipients to verify the authenticity of the email.

* <ins>**Domain Key Identified Mail (DKIM)**</ins> is a standard protocol for email authentication that allows a domain to claim responsibility for a message by attaching a digital signature. 
    - T. Hansen, D. Crocker, P. Hallam-Baker.  Domain Keys Identified Mail  (DKIM) Service Overview.  Internet Engineering Task Force.  RFC5585.  July 2009

* General Overview :

![Local Image](/images/chapter1/18.PNG)

1. Email Composition
    - A Gmail user composes an email with the body of the message.
2. Signing the Email
    - The Gmail server signs the email using its private key $(s_{k})$.
    - The signing process creates a signature $(\sigma)$ for the email body. The signature ensures the integrity and authenticity of the email.
    - The signed email is then sent out with the signature attached
3. Email Reception and Verification
    - The receiver gets the email with the attached signature.
    - To verify the signature, the receiver queries the DNS for Gmail's public key $(p_{k})$.
4. DNS Query
    - The receiver queries the DNS to retrieve the public key $(p_{k})$ of Gmail, which is used to verify the email signature
5. Verification
    - The receiver uses the public key $(p_{k})$ to verify the signature $(\sigma)$ attached to the email.
    - The verification process checks that the email body matches the signature and confirms that it was indeed signed by Gmail's signature key.

* This protocol prevents malicious actors from damaging the reputation of legitimate domains by sending spoofed emails.

### Chapter 2 Bank Card Payment

#### History of Payment

**Definition**

* <ins>**Payment**</ins>
    - Compensation, discharge, or performance of an obligation, or reimbursement
    - By giving over something that is of satisfactory value to its recipient such as money
* Paying is something human beings have to deal with since the dawn of time

**Timeline**

* Moving from bartering to bank notes took $\sim$ 8,000 years and moving from online payment to biometrics took $\sim$ 20 years.

**Business**

* Card-based payment is a business, with multiple stakeholders and legal rules.

![Local Image](/images/chapter2/1.PNG)

* Key Stackholders 
    - Customer/Payer : The individual or entity that initiates a payment using a card (credit, debit, etc.).
    - Merchant/Receiver : The business or individual that receives the payment in exchange for goods or services.
    - Issuing Bank : The bank that issues the payment card to the customer. This bank holds the account from which the payment is made
    - Acquiring Bank : The bank that receives the payment on behalf of the merchant. This bank processes the transaction and deposists the funds into the merchant's account.
    - Payment/Settlement Organization : An intermediary organization (such as Visa, Mastercard, or other payment networks) that facilitates the transfer of funds between the issuing and acquiring banks.

#### Bank Card Architecture

**Overview**

* There are three types of payment card
    - <ins>**debit card**</ins>
        * plastic payment card that can be used instead of cash when making purchases
        * the money is immediately transferred from the cardholder's bank account when performing a transaction
        * cfr. Bancontact system in Belgium
    - <ins>**charge card**</ins>
        * provides a direct debit payment method enabling the cardholder to make purchases that are paid for by the card issuer
        * card holder becomes indebted
        * the debt must be fully repaid to the card issuer by the due date, usually on a monthly basis
        * cfr. standard Visa/Mastercard
    - <ins>**credit cart**</ins>
        - revolving credit instruments that do not need to be paid in full every month
        - a balance may be carried over, on which an interest is paid
        - cfr. advanced Visa/Mastercard

* Overall structure of a payment card

    ![Local Image](/images/chapter2/2.PNG)

**Payment Account Number (PAN)**

* <ins>**Payment Account Number**</ins>
    - card number (a.k.a. primary account number)
    - identifier of the card
* Variable size
    - between 8 to 19 digits
    - commonly 16 digits
* Construction (16 digits)

    ![Local Image](/images/chapter2/3.PNG)

* <ins>**Major Industry Identifier**</ins>
    - telss what the card is for
    - very first digit (a digit ranges from 0 to 9)

    ![Local Image](/images/chapter2/4.PNG)

* <ins>**Issuer Identification Number (IIN)**</ins>
    - for identifying which bank owns the card
    - typically made of 6 digits
    - INN has been extended to 8 digits
    - PAN continues to remain of variable length
    - between 10 and 19 digits
    - INN main numbers (list available [here](https://en.wikipedia.org/wiki/Payment_card_number))

    ![Local Image](/images/chapter2/5.PNG)

* PAN checksum is computed using the <ins>**Luhn algorithm**</ins>
    - starting from the right, double the value of every second digit (e.g., 7 $\rightarrow$ 14)
    - sum the digits (e.g., 14 $\rightarrow$ 1 + 4)
    - validate a check digit $(sum + X) \% 10 = 0$
    - example

    ![Local Image](/images/chapter2/6.PNG)

* PAN is the payment card number security
* Credit cra numbers are important
    - can be bought and sold on black market
* Many expiration dates are not effective
    - after receiving the new card, the PAN is frequently the same

* IBAN (International Bank Account Number)
    - identifies the bank account across international borders
    - ensures payments are sent to the correct account in the correct country
    - contains the country code, check digits, bank identifier, account number (which uniquely identifies the specific account within the bank)
    - used for bank accounts
* PAN (Payment Card Number)
    - identifies a specific card account for processing card transactions
    - contains the Issuer Identification Number (INN), the account number, check digit
    - used for car accounts (debit, credit, charge)


**Card Verification Value (CVV)**

* <ins>**Card Verification Value**</ins>
    - Security feature for credit or debit card transactions, providing additional layer of verification and fraud prevention.
    - 3-4 digits
    - other names
        * CID for American Express cards (4 digits)
        * CVV2 for Visa cards (3 digits)
        * CVC2 for MasterCard cards (3 digits)
    - The CVV is linked to the card account and is used to verify that the card is in the possession of the cardholder during online or card-not-present transactions.
    - Elements Used in Generation Process of CVV
        * PAN (Primary Account Number)
        * Expiration Date
        * Service Code : A code that indicates the limitations and requirements for the card
        * CVK (Card Verification Key) : A secret key known only to the card issuer
    - Generation Mechanism
        * Encryption : The combination of the PAN, expiration date, service code and CVK are fed into an encryption algorithm.
        * Output : The output of this encryption process is the CVV, which is a 3- or 4-digit number

        ![Local Image](/images/chapter2/7.PNG)

* Steps for CVV Prompting in Online Transactions
    - Customer selects payment method
    - Payment form diplay. Fields usually include :
        * Card Number (PAN)
        * Expiration Date
        * Cardholder Name
        * CVV : security code 3-4 digit, usually found at the back of the card
    - CVV field in the payment form
    - Customer enters CVV (Visa/Mastercard usually have the CVV number on the signature strip on the back of the card)
    - Form Submission
    - Payment processor validation (it validates the CVV against the information on file with the card issuer to ensure the CVV matches the card number and expiration date provided). It ensures that the customer has the physical card in its possession.
    - Transaction approval or decline

* CVV security is compromised with phishing
* Testing the 1000 possible values
    - in $[000; 999]$
    - should (will ?) lead to error and account being blocked

**Magnetic Stripe**

* <ins>**Magstripe**</ins>
    - ISO 7811/1-5+ proprietary data format by MasterCard, Visa, AmEx, and individual banks
    - See [here]( https://www.q-card.com/about-us/iso-magnetic-stripe-card-standards/page.aspx?id=1457) for a good summary
    - Magstripe positioning is not random

    ![Local Image](/images/chapter2/8.PNG)

* A Magnetic Stripe contains 3 tracks (each 2.79mm wide)
    - Track 1 (IATA) : read-only and 79 x 6 bits, 210 bits/inch
        * Format Code 
            - A : reserved for proprietary use of card issuer
            - B : bank/financial
            - C-M : reserved
            - N-Z : available for use by individual card issuers
        * Service Code
            - digit 1 : interchange rules (e.g., 1 = international interchange OK)
            - digit 2 : authorization processing (e.g., 0 = normal)
            - digit 3 : range of services and PIN requirements (e.g., 0 = no restriction, PIN required)
        * PVV
            - See [here](https://www.ibm.com/support/knowledgecenter/en/SSLTBW_2.1.0/com.ibm.zos.v2r1.csfb400/csfb4za2598.htm)

    ![Local Image](/images/chapter2/10.PNG)

    ![Local Image](/images/chapter2/11.PNG)


    - Track 2 (ABA) : backup with low resolution of all data, except the name and 40 x 4+1 bits, 75 bits/inch

    ![Local Image](/images/chapter2/12.PNG)

    ![Local Image](/images/chapter2/13.PNG)

    - Track 3 (THRIFT) : usually unused, read-write, 107 x 4 bits

    ![Local Image](/images/chapter2/9.PNG)
    
**Chip Architecture**

* Typical chip architecture
    - be careful, chops may have many different contact pad layouts
    - J. Magiera, A. Pawlak.  Security Frameworks for Virtual Organizations.  In Virtual Organisations: Systems and Practices. December 2005.

    ![Local Image](/images/chapter2/14.PNG)

* <ins>**Voltage Common Collector (Vcc)**</ins>
    - power supply
* <ins>**Reset Signal (Rst)**</ins>
    - used to reset the card's communication
* <ins>**Clock**</ins>
    - a clock signal, from which data communications timing is derived
* <ins>**Ground**</ins>
    - zero voltage with respect to the power supply and ground plane of the board (reference voltage)
    - Vcc is above (+) or below (-) Gnd
* <ins>**Voltage Point to Point (Vpp)
    - external voltage for programming
* <ins>**Serial Input and Output (I/O)**</ins>
    - half duplex communication
    - communication in both directions, but one direction at time (not simultaneously)
* <ins>**Processor**</ins>
    - typically 8-bit microcontroller (we are seeing more powerful 16 and 32-bit processors)
    - different from standard CPU in computers (e.g., no multithreading)
    - execute machine instructions at speed of $\sim$ 1MIPS
    - a co-processor might be included to improve encryption/decryption speed and cipher
* <ins>**Electrically Erasable PROM (EEPROM)**</ins>
    - application storage (1 KB up to 32 KB)
    - content is not lost when power is (permanent storage)
    - typically store 
        * cryptographic keys
        * PIN code
        * biometric template
        * ...
* <ins>**Read-Only Memory (ROM)**</ins>
    - between 8 KB to 24 KB
    - store the chip OS
        * OS is made of a set of commands (20-30) to which the card responds
        * OS manages the card file system 
            - a file is a contiguous block in the card
            - files are organized in a hierarchical tree format
    - store other basic software (e.g., encryption algorithm)
* <ins>**Random Access Memory (RAM)**</ins>
    - 1 KB
    - needed for fast computation and response

#### Basic Payment Protocol

**Overview**

* The client, $Cl$, puts its card, $C$, in the terminal, $T$
* The marchant enters the amount, $M$, of the sale
* The terminal, $T$, authenticates the card, $C$
* The client, $Cl$, enters her PIN code
    - if $M \geq 100 ‚Ç¨$ then (in $20%$ of the cases)
        * the terminal, $T$, contacts the bank, $B$
        * the bank, $B$, gives its authorization

**Actors**

1. The bank, $B$
    - a private signature key, $s_{k}^{B}$
    - a public key to verify the signature, $p_{k}^{B}$
    - a secret key shared with the card, $s_{k}^{BC}$ (the bank has one secret key per card per client)
2. The card, $C$
    - some data (cardholder, expiry date, ...)
    - a signature of the data, $\sigma = S(data, s_{k}^{B})$
    - a secret key shared with the bank, $s_{k}^{BC}$
3. The terminal, $T$
    - a public key of the bank, $p_{k}^{B}$
4. The client, $Cl$
    - the PIN code

* Asymmetric cryptography for the bank in signing but the card and the bank share the private key which is symmetric cryptograhy. This is <ins>**heterogenous**</ins>.

**Protocol**

![Local Image](/images/chapter2/15.PNG)

1. $T$ reads Card $C$
    - The customer inserts or taps their card at the terminal, $T$. The terminal reads the card data, which includes the card number
2. The terminal, $T$, asks for the PIN
3. The terminal, $T$, requests authorization to B
4. The card uses this number to ask authorization using encryption with the private shared key between the card and the bank and the number.
5. The bank verifies the authorization and sends response which the terminal uses to confront the client

**Attack**

* YesCard
    - historical attack
    - 1998, Serge Humpich
    - counterfeit EMV card that has been manipulated to always approve transactions, regardless of the actual card data or the PIN entered
* Flaw in the payment protocol
    - the pair (Data, $\sigma$) is stored in plain text in the card (easy to read it and reproduce it on another card)
    - RSA is used for encryption/decryption (same key since 1990 and 320 bits is easy to factorize in 1998)
* Attack
    - payment card always responds yes to PIN code
    - worked because asking authorization to B was not mandatory
* YesCard is a one shot
    - the card was usually banned by $B$ the same day

#### Europay MasterCard And Visa

**Overview**

* <ins>**Europay, Mastercard and Visa**</ins>
    - de facto global standard for credit/debit card
* Based on four books
    - EMV.  Application Independent ICC to Terminal Interface Requirements.  Book 1, version 4.3.  November 2011.
    - EMV.  Security and Key Management.  Book 2, version 4.3.  November  2011.
    - EMV.  Application Specification.  Book 3, version 4.3.  November 2011.
    - EMV.  Cardholder, Attendant, and Acquirer Interface Requirements.  Book 4, version 4.3.  November 2011.
* EMV payment is a four steps process
    - simplified version

    ![Local Image](/images/chapter2/16.PNG)

1. The terminal requests, from the card, all information required to process the transaction.
2. The terminal confirms the card is legitimate.
3. The terminal confirms the person presenting the card is legitimate (e.g., PIN)
4. The terminal confirms the card's account has adequate funds for the transaction

* Actors 

    ![Local Image](/images/chapter2/17.PNG)

* Issuer/Acquirer authentication process

    ![Local Image](/images/chapter2/18.PNG)

    - CA (Certificate Authority) has its own public/private keys pair. It is responsible for issuing digital certificates and managing keys.
    - Issuing bank is responsible for managing card personalization.

1. Keys Generation by Issuing Bank
    - The EMV issuing bank generates a pair of cryptographic keys (public and private keys).
2. Certificate Generation Request
    - The issuing bank sends its public key along with a request for a certificate to the CA.
3. Certificate Issuance by CA
    - The CA uses its private key to sign the public key of the issuing bank, crrating a digital certificate. This certificate proves the authenticity of the public key. The signed certificate is sent back to the issuing bank.
4. Card Personalization
    - The issuing bank embeds the signed certificate and the signature onto the EMV card
    - The card now contains
        * Public key certificate and CA's signature
        * Private key (used for signing transition data)
        * Public key (part of the public/private key pair)
    - The issuing bank loads the public key certificate (issued by the CA) and other necessaty data onto the EMV card
    - The EMV card also has its own key pair (public and private keys) used for signing transaction data.
5. Configuration and Public Key Sharing
    - A : The CA shares its public key with the EMV
    - B : The acquiring bank configures the EMV terminal with the CA's public key.

* Transaction Authentication Process
    - Card and Terminal Interaction
        * The EMV terminal reads the card data, including the public key certificate.
    - Verification by Terminal
        * The terminal uses the CA's public key (configured during setup) to verify the issuing bank's certificate on the card.
        * If the certificate is valid, the terminal can trust the public key on the card.
    - Transaction Data Signing
        * The EMV card uses its private key to sign the transaction data (e.g., card number, transaction amount).
    - Signature Verification
        * The terminal sends the signed transaction data to the acquiring bank.
        * The acquiring bank verifies the signature using the public key from the card's certificate.

The <ins>**authentication**</ins> process involves a chain of trust established through digital certificates issued by a Certificate Authority. The issuing bank generates key pairs and obtains a certificate from the CA, which is then embedded in the EMV card. The acquiring bank configures terminals with the CA's public key to verify the certificates presented by the cards. This process ensures that during a transaction, the EMV terminal can verify the authenticity of the card and the transaction data, providing a secure and trusted payment environment.

**Application Data**

* Read application data
    - account details such as the PAN (Personal Account Number), cardholder name, expiry date
    - copy of magstripe details for backward compatibility with older systems that may still rely on magnetic stripe information
    - acceptable types of cardholder verification types
        * CVM (Card Verification Method) List, a list of methods used to verify the card's identity
            - PIN (Personal Identification Number)
            - Signature
            - No CVM required for contactless payments for example
            - Online PIN
    - issuer's public key (thus of the issuing bank) and certificate (digital certificate validating issuer's public key)
    - signature of some data under issuer's key
        * SDA (Static Default Authentication) only
            - involves verifying a digital signature created by the issuer using their private key. The signature is checked against the issuer's public key to ensure the data has not been altered.
            - This method is used to validate static data that does not change from transaction to transaction.
    - card's public key and certificate(s)
        * DDA (Dynamic Default Authentication) only
            - involves generating a unique digital signature for each transaction using the card's private key. The terminal verifies the signature using the card's public key.
            - This provides stronger security compared to SDA, as it includes dynamic data that changes with each transaction, making it harder for attackers to duplicate or forge transactions.
            - The card's public key is validated through a digital certificate signed by the issuer, ensuring the authenticity of the card's public key

* Certificate/Key exchanged between card and terminal (part of the verification in an EMV transaction)

![Local Image](/images/chapter2/19.PNG)

1. Send Certificate
    - During a transaction, the EMV card sends its digital certificate to the terminal. This certificate includes the issuer's public key validated by the CA.
    - This certificate does not include the card's public key but verifies the issuing bank's public key.
2. Decrypt Signature
    - The terminal receives the certificate and uses the CA's public key to decrypt the digital signature on the certificate.
    - Decrypting the signature verifies that the certificate was indeed issued by the CA and extracts the issuing bank's public key.
    - Decrypting extracts the hash value that was signed by the CA which is the issuing bank.
3. Hashing and Comparison
    - Hashing between extracted data from certificate and computed hash from data received from the card.
    - It ensures data from the card hasn't been modified (integrity check).
    - Use of CA's public key ensures the authenticity of the card.
4. Card Authentication and Signing
    - The EMV card uses its private key to sign the transaction data data
    - The signed transaction data and the issuer's public key certificate are sent to the terminal
5. Signature verification
    - The terminal uses the issuing bank's public key (from the decrypted certificate) to verify digital signature on the transaction data
6. Role of Card's Public and Private Keys
    - The card's private key is used to sign the transaction data, ensuring that the data is authenticated.
    - Public key is used to verify signatures created by the card's private key during advanced authentication processes like DDA, etc.

* Data management in card
* File structure is based on a tree structure
    - root (MF = <ins>**Master File**</ins>)
    - directories (DFs = <ins>**Dedicated Files**</ins>)
    - actual data (EFs = <ins>**Elementary Files**</ins>)

    ![Local Image](/images/chapter2/20.PNG)

    - Each EF contains an <ins>**Application Identifier**</ins> for matching files with application.

**Card Authentication**

* There are 3 techniques for card authentication
    - <ins>**Static Default Authentication (SDA)**</ins>
        * Default
        * Cheapest option
        * Deprecated
    - <ins>**Dynamic Default Authentication (DDA)**</ins>
        * More expensive option
        * Now pretty much common
    - <ins>**Combined Data Authentication**</ins>

1. SDA
    - When personalizing the card, the issuer selects static data
    - Static data is hashed an ciphered with the issuer private key : <ins>**Signed Static Application DATA (SSAD)**</ins>
    - Static data and SSAD stored on the chip

    ![Local Image](/images/chapter2/21.PNG)
    
    - Card Authentication (green key is the issuer's public key extracted from certificate, blue key is the CA public key)
    
    ![Local Image](/images/chapter2/22.PNG)

    - Limits 
        * Card can be cloned and any data involved in SDA can be read.
        * What happens in case the issuer private key is stolen ? All cards become breakable.
2. DDA
    - Requires the presence of the cipher co-processor in the chip.
    - The main difference lies at the personalization time. Two session keys are derived from the issuer keys and stored in the private area of the chip.

    ![Local Image](/images/chapter2/23.PNG)

    ![Local Image](/images/chapter2/24.PNG)

    ![Local Image](/images/chapter2/25.PNG)

3. CDA
    - combines DDA and application cryptogram generation
    - <ins>**Cryptogram**</ins>
        * a communication in cipher 
    - cryptograms are sent to issuer to confirm the legitimacy of the transaction

    ![Local Image](/images/chapter2/26.PNG)

    ![Local Image](/images/chapter2/27.PNG)

**Cardholder Verification**

* Depends on the transaction type
    - Magstripe transaction (data acquired only through the magstripe)
        * *on-line ciphered PIN*
            - holder enters the PIN
            - PIN is ciphered and sent to the bank for verification
            - e.g. old ATM with only magstripe reader
        * *handwritten signature*
            - holder signs the invoice
            - e.g. the POS is onnly able to read the magstripe
        * *no verification*
            - e.g. when you pay the highway in France
    - Chip-based transaction (EMV)
        * *on-line ciphered PIN*
            - same as for magstripe transaction
        * *off-line ciphered PIN*
            - PIN-PAD ciphered the PIN and send it to the card for verification
            - e.g. your bank PAD for on-line shopping
        * *off-line plain PIN*
            - PIN is directly send to card fir verification
            - e.g. payment on a POS
        * *handwritten signature*
            - same as for magstripe transaction
        * *off-line plain/ciphered PIN + signature*
            - double verification
            - e.g. when the amount is above a threshold, it may require a double verification

**Transaction Authorization**

* There are 2 types of transactions
    - offline transaction
        * no contact with banks
        * the POS and the card authorize (or not) together the transaction based on risk parameters
    - online transaction
        * requires a contact with both acquiring and issuing bank
    
    ![Local Image](/images/chapter2/28.PNG)

#### Contactless Payment

**Overview**

* Electromagnetic induction : NFC
* Antennas are present in the terminal and the card
* The signal powers the card and carries the data
* The modulation used to transmit data varies according to the type of card
* Based on three books :
    - EMV.  Architecture and General Requirements.  Book A, version 2.8.  May 2019.
    - EMV.  Entry Point.  Book B, version 2.8..  May 2019.
    - MV.  Kernel 2 Specification.  Book C, version 2.8.  May 2019.

**Radio Frequency IDentification (RFID)**

* <ins>**Radio-Frequency IDentification**</ins>
    - use of radio frequency tags to identify real objects
* Identfy ?
    - assign IDs to objects
    - link the ID to additional information about the object
    - link the ID to complementary info
    - find similar object
* Identification examples
    - bar codes
    - license plates
    - student ID
    - car keys
    - ...
* RFID is based on 3 components
    - <ins>**Transreceiver**</ins>
        * Tag reader
    - <ins>**Transponder**</ins>
    - <ins>**Antenna**</ins>

    ![Local Image](/images/chapter2/29.PNG)

* There are 2 types of tags
    - <ins>**Passive**</ins> tags
        * no battery (powered derived from the field generated by the reader)
        * unlimited life
        * require more powerful readers
        * orientation sensitive
        * low cost
    - <ins>**Active**</ins> tags
        * powered by an internal battery
        * finite lifetime because of the battery
        * greater range
        * better noice immunity
        * higher data transmission rates
* A tag can be
    - read-only
        * factory programmed
        * usually chipless
        * cheap
    - write once/read many
    - read/write
        * on board memory
        * can save data
        * can change ID
        * higher cost
* Frequency bands
    - primary importance when determining data transfer rates
    - the higher the frequency, the higher the data transfer rate

    ![Local Image](/images/chapter2/30.PNG)

**Near-Field Communications (NFC)**

* Near-Field Communication
    - promoted by NFC forum
        * non profit industry association
        * formed on March 18th, 2004
        * founders : NXP Semiconductors, Sony, Nokia
        * promotes implementation and standardisation of NFC
    - standard to establish radio communication between devices by touching or bringing them into close proximity
    - builds upon RFID (works at 13.56 MHz)
    - distance needed : $\leq$ 10 cm (theoritically $\leq$ 20 cm)
    - rates : 106, 202, or 424kbit/sec
* <ins>**Field**</ins>
    - radiations radiated by the antenna
* Near Field
    - fields that are in close vicinity of the antenna
* NFC communicates via magnetiic field induction
    - where 2 loop antennas are located within each other's near fields, forming an air-core transformer

    ![Local Image](/images/chapter2/31.PNG)
* Communication schemes
    - passive communication
        * initiating device produces carrier field
        * the target device, when introduced to this field, uses it to draw energy
    - active communication
        * initiator and target both generate an RF field
        * each side transmits data by modifying its own field
* Communication modes
    - *read-write mode*
        * system performs the functions of a contactless reader/writer
        * system's NFC interacts with NFC device and either read data in it from the device or write data out to it
        * passive mode (no need of power source for target)
        * can embed a Secure Access Module (SAM) to encrypt data
    - *peer-to-peer mode*
        * 2-way communication channel between a pair of NFC devices
        * each device can initiate the communication
        * passive or active mode
    - *card emulation mode*
        * the system behaves as a compliant contactless smartcard
        * passive mode

**Security**

* Despite the contact between the card and the POS is wireless, EMV protocol still holds
    - I. Lacmanovic, B. Radulovic, D. Lacmanovic.  Contactless Payment Systems Based on RFID Technology.  In Proc. 33rd International Convention on Information and Communication Technology, Electronics and Microelectronics (MIPRO).  May 2010.
    - D. Lacmanovic, I. Lacmanovic.  Contactless Payment Based on Near-Field Communication Technology.  In E-Society Journal: Research and Applications.  2(2), pg. 75-83.  November 2011.
* Card issuers ensure that 
    - readers can only performs a single transaction at a time (no multiple payments for the same purchase)
    - purchase cannot be made without consumer knowledge
        * the amount must be first entered by the retailer
        * the card must be within 10 cm of the reader
* Contactless cards also ensure
    - mutual authentication
        * reader and card authenticate themselves
        * card authentication in EMV
    - encryption
        * any exchange between card and reader is ciphered
        * digital signature with "dynamic" keys (CDA in EMV)
    - protection against replay
        * dynamic data is generated for every transaction
        * cryptograms in EMV
    - PIN required if amount tp pay $\geq$ a given threshold (30 $‚Ç¨$ in Belgium and 30 $‚Ç¨$ in France)
* Be careful
    - there is no limit in the amount of transactions per day (outdated)
    - if you loose the card, anyone can perform purchase for less than the threshold ...

### Chapter 3 Merkle Tree

#### Problem

* Bob stores a set of items for Alice
    - Alice keeps a single value
    - Alice can validate the items returned to her

    ![Local Image](/images/chapter3/1.PNG)

* How can we efficiently achieve that ?
* First Solution
    - Alice keeps the hash of the entire items set
    - $s = H(x_{1}, x{2}, x_{3}, ...)$
    - validation of an item

    ![Local Image](/images/chapter3/2.PNG)

    - Drawbacks
        * Bob must send the entire set of items for validation
        * Let $n$, be the size of the set
        * $O(n)$ traffic for validating a single item (not scalable)
* Second Solution
    - validating an item
    - The diagram illustrates a method for efficiently validating an item using a cryptographic proof, typically in the context of Merkle trees or similar structures. This process allows Alice to validate items stored by Bob without having to store all the items herself.
    - Bob sends Alice an item $X_{2}$ and a logarithmic size proof. The proof is a series of hashes that Alice can use to verify that $X_{2}$ is part of the set Bob stored.
    - Alice uses the item $X_{2}$ and the provided proof to compute a hash. This computation typically involes combining $X_{2}$ with the hashes in the proof to reconstruct the root hash.
    - Alice compares the computed hash with the root hash she has saved. If the computed hash matches the saved root hash, Alice can be confident that $X_{2}$ is a valid itemm from the set stored by Bob. If not, the item or the proof is invalid.
    
    ![Local Image](/images/chapter3/3.PNG)

#### Principle

**Overview**

* <ins>**Merkel Tree**</ins>
    - R. C. Merkle.  A Digital Signature Based on a Conventional Encryption Function.  In Proc. Conference on the Theory and Application of Cryptographic Techniques on Advances in Cryptology (CRYPTO).  August 1987.
    - but patented in 1979 ...
* Principle
    - combines hash functions and binary tree structure
    - an authentication scheme
        * using only one-way hash function as building blocks
        * no number theory or trapdoor permutation
* More formally
    - a tamper-resistant data structure allowing a large amount of data to be compressed in a single hash
    - can be queried for the presence of specific elements in the data with a proof construction in logarithmic space
* Merkle tree
    - binary tree
    - leaves corresponds to hashes of data to check
    - each internal node corresponds to a hash of left and right children
    - the root of the tree, the <ins>**Merkle Root**</ins>, is made pubic (this is the information kept by Alice)
    - A binary tree where each leaf node is a hash of an item, and each non-leaf node is a hash of its two child nodes. The root is a single hash representing the entire set.

**Construction**

* Merkle tree construction

![Local Image](/images/chapter3/4.PNG)

**Verification**

* Verification of an item $d$

![Local Image](/images/chapter3/5.PNG)

#### Use Cases

**Distributed Version Control**

* Git data model
    - state based data model
    - 3 types of objects
        * commits
        * trees (directories)
        * blobs (files)
    - see [here](https://git-scm.com/book/en/v2/Git-Internals-Git-Objects)

    ![Local Image](/images/chapter3/6.PNG)

* Git objects have all the same format

![Local Image](/images/chapter3/7.PNG)

* Objects are 
    - stored compressed `gzcompress(Object)`
    - hashed for data integrity `object id = H(Object)`

* Blob objects
    - type = "blob"
    - data contains the blob content

* Tree object
    - type = "tree"
    - data contains a list of tree entries

    ![Local Image](/images/chapter3/8.PNG)

* Example

![Local Image](/images/chapter3/9.PNG)

* Commit object
    - type = "commit"
    - data is follow

    ![Local Image](/images/chapter3/10.PNG)

* Example

![Local Image](/images/chapter3/11.PNG)

* Git data integrity
    - commit hash depends on all child tree/blob hashes and parent commits
        * commit hash is a signature for the entire data
        * Merkle Tree !

        ![Local Image](/images/chapter3/12.PNG)        

**BitTorrent**

* BitTorrent
    - peer2peer (P2P) file transfer protocol
        * created in 2001 by Bram Cohen
        * B. Cohen.  The BitTorrent Protocol Specifiation.  Standard's Track.  BEP 3.  January 2008.
    - transfer of large files
        * files are shared by many users
    - active participation of all users
* General idea
    - a file is broken into many different <ins>**pieces**</ins> (256 KB - 2 MB)
    - pieces are split into <ins>**blocks**</ins> (16 KB)
    - blocks downloaded in a "rarest" first manner
    - The rarest first algorithm in BitTorrent is a strategy used for efficient piece selection by BitTorrent clients, not routers. Here‚Äôs how it works:   
        * Missing Pieces: When a client needs to download missing pieces of a file, it maintains a list of these pieces.
        * Rarity: The algorithm selects the rarest missing piece first. In other words, it prioritizes the piece that the fewest neighboring peers have.
        * Random Choice: If multiple pieces have the same rarity, the algorithm randomly chooses one of them to download. This ensures that the availability of pieces is spread out, reducing the risk of any piece going extinct even if all seeders disappear.
    - downloaded done with TCP and pipelining (to avoid TCP slow start delay)
    - blocks are downloaded in parallel from multiple peers
* Example
    - file divided into 13 chunks
    - file shared by 4 peers
    - file downloaded by a peer

    ![Local Image](/images/chapter3/13.PNG)
* Downloads start with `.torrent` file
    - encoded using bencoding
        * encoding scheme used by P2P file sharing protocol for storing and transmitting loosely structured plan
    - information
        * length of the content in bytes
        * file name
        * piece length
        * hashes for all pieces
* Containing hashes for all pieces may lead to large `.torrent` file
* Merkle tree to the rescue
    - A. Baker.  Merkle Hash Torrent Extension.  Standard's Track.  BEP 30.  March 2009
* Hashes of pieces are organized into a Merkle tree
* `.torrent` file only contains the Merkle root

**File Systems**

* Multiple advanced file systems rely on Merkle tree
    - InterPlanetary File System (IPFS)
        * BitTorrent swarm for exchanging objects stored in GIT
        * J. Benet.  IPFS - Content Addressed, Versioned, P2P File System.  arXiv cs.NI:1407.3561.  July 2014.
    - Merkle-Tree-Based File System (MTF)
        * file storage in a Blockchain
        * Blockchain organized as cluster in which distributed random nodes provide a secure private storage service
        * Merkle tree used to ensure files are distributed among the nodes in a balanced way
        * J. Kan, K. S. Kim.  MTFS: Merkle-Tree-Based File System.  In Proc. IEEE Conference on Blockchain and Cryptocurrency.  May 2019.
    - Zettabyte File System (ZFS)
        * blocks of a ZFS storage pool form a Merkle tree in which each block validates all of its children
        * J. Bonwick, M. Ahrens, V. Henson, M. Maybee, M. Shellenbaum.  The Zettabyte File System.  2003.

**No-SQL Databases**

* <ins>**No-SQL**</ins>
    - Not only SQL
    - SQL style querying is not the crucial objective
* Main features of No-SQL data storage
    * avoid unneeded complexity
    * support flexible schema
    * scale horizontally
    * provides scalability and high availability by storing and replicating data in distributed systems, often in data centers
    * useful when working with Big Data and when the data's nature does not require a relational model (traditional *join* operations cannot be used)
    * do not typically support ACID (Atomicity-Consistency-Isolation-Durability) properties but rather BASE (Basically Available-Soft State-Eventually Consistent)
* BASE ?
    - **B**asically **A**vailable
        * the system is available most of the time
        * there could exist a subsystem temporarily unavailable
    - **S**oft State
        * data is not durable
        * its persistence is in the hand of the user that must take care of refresh them
    - **E**ventually consistent
        * the system eventually converge to a consistent state
* BASE is an optimistic approach
    - lets conflict occur, but deletes them and takes action to short them out
    - conditional updates (test the value just before updating)
    - save both updates (record that they are in conflict and then merge them)
* Amazon's <ins>**Dynamo**</ins>
    - highly available and scalable distributed key-value data store built for Amazon's platform
    - G. DeCandia, D. Hastorun, M. Jampani, G. Kakulapati, A. Lakshman, A. Pilchin, S. Sivasubramanian, P. Vosshall, W. Vogels.  Dynamo: Amazon's Highly Available Key-Value Store.   In Proc. USENIX Symposium on Operating Systems Principles (SOSP).  October 2007
* Dynamo uses Merkle tree for
    - detecting faster inconsistencies between replicas
    - minimizing the amount of transferred data
* Example
    - if the Merkle root of two trees are equal, leaves are also equal and no synchronization is required
    - if not, values of some replicas are different
        * nodes may exchange hash values of children and the process continues until it reaches the leaves of the trees
        * the hosts can then identify the keys that are "out of sync"

### Chapter 4 Blockchains

#### Overview Blockchain

**Generalities**

* A Blockchain <ins>**is not**<ins> bitcoin
    - or other cryptocurrencies
    - bitcoin uses Blockchain
* A Blockchain is a technology
    - S. Nakamoto.  Bitcoin: A Peer-to-Peer Electronic Cash System.  2008
* It is a distributed database
    - maintains a continuously growing list of records
        * <ins>**Blocks**</ins>
    - transactions are grouped into a Block
    - new Blocks are appended at the end of existing ones
        * no deletion
        * organisation of Blocks in chronological order
    - uses cryptography to prevent altering tampering
* Distributed ledger/database
    - there is one ledger
        * all nodes have some level of access to that ledger
    - all nodes agree to a protocol that determines the "true state" of the ledger at any pointn in time
        * applictaion of this protocol is called <ins>**achieving consensus**</ins>
    
    ![Local Image](/images/chapter4/1.PNG)
* What is a distributed ledger ?
    - A distributed ledger is a type of database that is shared, replicated, and synchronized across multiple nodes (computers or entities). Unlike a centralized database, a distributed ledger does not rely on a single central point of control. This decentralization enhances security, transparency, and resilience.
    - Single Entity
        * The left diagram shows a distributed ledger within a single entity
        * Nodes A, B, C, D and E are all part of the same organization or entity
        * Each node maintains a copy of the entire ledger and participates in the consensus process to validate and record transactions
        * In this setup, even though the ledger is distributed across multiple nodes, they all belong to the same organization
        * This could be a private blockchain or permissioned blockchain where the organization has control over who can join the network and participate in the consensus process
        * Example : A company's internal blockchain used for tracking supply chain logistics, where all nodes are owned and managed by the company
    - Multiple Entity
        * The right diagram shows a distributed ledger across multiple entities
        * Nodes A, B, C, D, and E belong to different organizations or entities
        * Each node still maintains a copy of the entire ledger and participates in the consensus process to validate and record transactions
        * The nodes are interconnected and form a network where each entity has an equal role in maintaining the ledger
        * This setup is typical of public blockchains or consortium blockchains
        * Public blockchains (e.g., Bitcoin, Ethereum) are open to anyone, and nodes can join and leave the network freely
        * Consortium blockchains involve a group of organizations that collaboratively maintain the ledger and manage the blockchain
        * Example : A consortium of banks using a blockchain netwrok for interbank settlements, where each bank operates its own node

    ![Local Image](/images/chapter4/2.PNG)

**Big Picture**

* A Blockchain is a combination of existing principles
    - forward chaining : attaching one Block to another
    - Merkle Tree : verifying the transactions in a Block
    - ...
* Big picture of a Blockchain

![Local Image](/images/chapter4/3.PNG)

* Generally speaking, how does it work ?
    - users initiate transactions using their digital signatures
    - users broadcast their transactions to Nodes
    - one or more Nodes begin validating each transactions
    - Nodes aggregate validated transactions into Blocks
    - Nodes broadcast Blocks to each other
    - Consensus protocol used
    - Block reflecting "true state" is chained to prior Blocks
    - Each block contains the hash of the previous block in the chain. This links the block together, creating a sequence that is cryptographically secure.
    - The hash of a block is dependent on both its data and the hash of the previous block. This means that if any block's data is altered, its hash will change, which will affect all subsequent blocks.
    - The integrity of the blockchain relies on the cryptographic linking of blocks. If an attacker tries to alter the data in Block 1, the hash of Block 1 changes. This change propagates to Block 2 since Block 2 includes the hash of Block 1 and then to Block 3 and so on. Because each block contains the hash of the previous block, any change in the data or hash of one block will invalidate the hashes of all subsequent blocks. This interconnectedness ensures the immutability of the blockchain. Any attempt to alter data will be immediately noticeable because the hashes will no longer align.
    - <ins>Secure, decentralized record-keeping**</ins>
* Where might Blockchain use cryptography ?
    - initiation and broadcasting of transactions
        * digital signatures
        * public/private keys
    - validation of transaction
        * proof of work
        * other alternatives
    - chaining of Blocks
        * hash functions

**Key Characteristics**

* <ins>**Decentralization**</ins>
    - no central point
    - no risk of single point of failure
* <ins>**Immutability**</ins>
    - any modification in the previous Block automatically invalidates all the consequently generated Blocks
    - any falsification in the transactions can be detected with the Merkle Root
* <ins>**Non-Repudiation**</ins>
    - transactions are cryptographically signed with private keys
* <ins>**Transparency**</ins>
    - every user can access and interact with the Blockchain network with an equal right.
* <ins>**Pseudonimity**</ins>
    - privacy preserved at a certain level
    - Blockchain can be used to preserve privacy of personal data
        * G. Zyskind, O. Nathan, A. Pentland.  Decentralizing Privacy: Using Blockchain to Protected Personal Data.  In Proc. IEEE Security and Privacy Workshop.  May 2015
* <ins>**Traceability**</ins>
    - each transaction recorded is attached with a timestamp
    - historical data can be easily traced

#### Block

**Overview**

* Global overview of a Block
    - The graph shows how the average block size in the Bitcoin blockchain has changed over time.
    - Over time, the block size has increased, indicating a growing number of transactions being included in each block.
    - The graph shows fluctuations and periodic spikes, which could correspond to periods of high transactions volume or specific events in the Bitcoin ecosystem.
    - Implications : Scalability, Network Congestion and Technological Development to solve scalability problems, larger transaction loads problems etc. 

![Local Image](/images/chapter4/4.PNG)

**Header**

* Header contains
    - hash towards the previous Block
    - version
        * structure of the data inside the Block
        * used for reading the contents of each Block correctly
    - timestamp
        * Unix time
        * valid if
            * greater than the median timestamp of previous 11 Blocks
            * less than the network-adjusted time + 2 hours
        * timestamp shows that Blocks are connected in chronological order
        * proves when and what happened on the Blockchain
        * Example with Bitcoin

        ![Local Image](/images/chapter4/5.PNG)

        * The chronological integrity is based on the timestamp and ensures that all blocks are connected in a chronological order, forming a secure and tamper-proof chain.
        * Historical record proving when each block and the transaction it contains was added to the blockchain.
        * Security : this mechanism prevents tampering because altering a block's timestamp would change its hash and invalidate all subsequent blocks.
    - nonce
        * random number used for varying the input to a cryptographic hash function (to obtain a hash for a certain input that fulfills certain arbitrary conditions)
        * used to reach consensus on block validity (e.g., incremented by the proof of work)
    - Merkle Root
    
* Why the hash doesn't change over time ?
    - Static hashes : once a block is mined, its hash is fixed. The hash does not change periodically or over time. It remains the same unless the block's data is altered.
    - Chain Integrity : the hash is a unique fingerprint of the block's content at the time it was mined. Changing any part of the block, even a small change like the timestamp, will produce a completely different hash.
* Preventing Tampering
    - Chain of Trust : Each block's hash includes the previous block's hash, creating a chain of trust. This means any change to a block requires recalculating the hsh for that block and all subsequent blocks.
    - Computational Effort : To alter a block and successfully tamper with the blockchain, an attacker would need to re-mine the altered block and all subsequent blocks. This is computationally infeasible due to proof-of-work mechanism

1. Block Hash Calculation
    - When a block is mined, its hash is calculated based on its contents : data, previous block's hash, timestamp, nonce, and other metadata.
    - The hash is a unique fingerprint of the block's contents at the time it was created
2. Static Nature of Hashes
    - Once the hash is calculated and the block is added to the blockchain, the hash remains static unless the block's contents are altered
    - Any alteration to the block's contents, including the timestamp, will change the hash
3. Detection of Tampering
    - The blockchain relies on the consensus mechanism and the distributed nature of the ledger to detect and prevent tampering.
    - Every node in the network maintains a copy of the blockchain. These nodes continouously verify the integrty of the blockchain by checking the hashes of the blocks

* How Tampering is Detected ?
    - Consensus Mechanism
        * Nodes in the network use consensus algorithms (e.g., Proof of Work, Proof of Stake) to agree on the validity of new blocks and the sate of the blockchain.
        * If an attacker tries to tamper with a block, the altered block will have a different hash, breaking the chain of subsequent blocks.
    - Verification Process
        * When a node receives a block, it verifies the block's hash against its contents. It also verifies the hash of the previous block.
        * If the hashes do not match, the block is rejected as invalid.
    - Distributed Ledger
        * Since the blockchain is distributed, any node can detect tampering. When nodes receive different versions of the blockchain, they follow the version with the longest chain and valid proof of work.
        * If an attacker tries to propagate a tampered blockchain, the honest nodes will reject it because the hashes will not match the expected values

**Data**

* How are Transactions Handled and How are Blocks Added to the Blockchain in a Peer-To-Peer (P2P) Network ?

1. Transactions are broadcasted to all nodes
    - When a transaction is initiated, it is broadcast to all nodes in the P2P network.
    - Each node independently verifies the transaction's validity by checking the sender's signature and ensuring that the sender has sufficient funds.
2. A Node collects transactions in a Block
    - Verified transactions are collected by a node (often called a miner or validator)
    - The node groups these transactios into a block
3. Compute Consensus
    - The node that collects the transactions attempts to add the block to the blockchain
    - The node must solve a cryptographic puzzle to prove the block's validity (Proof of Work) and show a stake in the network (Proof of Stake), depending on the consensus algorithm used
    - The process of solving this puzzle or demonstrating stake is called computing consensus
4. Broadcast new block to the network
    - Once a node successfully computes the consensus and creates a valid block, it broadcasts the new block to the entire network
    - This block includes the hash of the previous block, ensuring it is linked to the existing blockchain
5. Other nodes verify the consensus algorithm and accept the block
    - The other nodes in the network receive the new block and verify its validity
    - Verification includes checking the block's hash, ensuring it includes the correct previous block's hash, and confirming that the consensus puzzle has been correctly solved
    - If the block is valid, nodes add it to their copy of the blockchain

* Proof of Work : Nodes (miners, special type of nodes inside Blockchain network) compete to solve a difficult cryptographic puzzle. The first one to solve it gets to add the block to the blockchain and is rewarded.

* Proof of Stake : Nodes are chosen to add the block based on their stake in the network, which might involve holding a certain amount of the blockchain's currency.

![Local Image](/images/chapter4/6.PNG)

* How many transactions per Block ?
    - average amount of transactions per Block for Bitcoin
    
    ![Local Image](/images/chapter4/7.PNG)

* How long does it take for a transaction to be added to the blockchain ?
    - median time for a transaction to be accepted and added (Bitcoin)

    ![Local Image](/images/chapter4/8.PNG)

#### Use Cases Blockchain

**Smart Contracts**

* <ins>**Smart Contract**</ins>
    - user-defined program running on top of a Blockchain
        * code written in, e.g., Solidity or Vyper
        * Blockchain is e.g., Ethereum
    - stimulates trusted third party with shared state

    ![Local Image](/images/chapter4/9.PNG)

* Original definition
    - N. Szabo.  The Idea of Smart Contracts. 1994
* A smart contract is
    - computerized transaction protocol
    - that executes the terms of a contract (payment, confidentiality, enforcement, etc.)
* General objectives
    - satisfy common contractual conditions
    - minimize exceptions both malicious and accidental
    - minimize the need for trusted intermediaries
    - related economic goals include lowering fraud loss, arbitrations and enforcement costs, and othr transaction costs
* Properties
    - guaranteed to execute correctly
        * malicious miner cannot cheat (see Mt Gox)
    - transactions are all-or-nothing (this refers to its atomicity : the transaction is indivisible, either it completes fully and is recorded in the Blockchain or it fails entirely and none of its effects are recorded)
    - Note that once a block is successfully added to the Blockchain meaning it was verified by the network for consensus, then all transactions within that block are considered confirmed.
    - autonomous
        * enforced by network
        * cannot be changed or stopped even by its creator
    - all data is stored on the Blockchain
        * audible history
* Typical applications
    - tokens
    - lotteries
    - insurance
    - supply-chain management
    - sharing economy
    - ...
* Be careful on known attacks
    - reentrancy
    - front-running
    - timestamp dependence
    - integer overflow and underflow
    - ...
    - see details on smart contract [known attacks](https://consensys.github.io/smart-contract-best-practices/)

**Access Control**

* Medical Data Sharing
    - S. Rouhani, L. Butterworth A. D. Simmons, D. G. Humphery, R. Deters.  MediChainTM: A Secure Decentralized Medical Data Asset Management System.  In Proc. IEEE International Conference on Computer and Information Technology.  July/August 2018.

    ![Local Image](/images/chapter4/10.PNG)
* Audible access control
    - integration of a traditional access control system with Blockchain technology
    - access control policies are implemented as smart contract
    - the audibility property derives from properties of smart contracts and Blockchain
    - D. Maesa, P. Mori, L. Ricci.  A Blockchain Based Approach for the Definition of Auditable Access Control Systems.  In Computers & Security, vol. 84, pg. 93-119.  July 2019.
* Hierarchical access control on IoT
    - M. Ma, G. Shi, F. Li.  Privacy-Oriented Blockchain-Based Distributed Key Management Architecture for Hierarchical Access Control in the IoT

    ![Local Image](/images/chapter4/11.PNG) 

**Food Traceability**

* Standard food supply chain (*from farm to fork*)
* Digitalized food supply chain
* BlockChain food supply chain
    - *provider*
        * informtion about crops, pesticide, fertilizer used, machinery used, ...
        * transactions with the producer/farmer are recorded
    - *producer*
        * information about the farm and farming practices emloyed
        * additional information about cultivation process, animals, ...
    - *processing*
        * information about factory and its equipment, processing methods, ...
        * financial transactions with the producers and the distributors are recorded
    - *distribution*
        * shipping details, trajectories followed, strorage conditions (temperature, humidity, ...), ...
        * transactions between distributors and final recipients (retailers) are recorded
    - *retailer*
        * information about each food item, its current quality/quantity, expiration dates, storage conditions and time spent on the shelf
    - *consumer*
        * uses a mobile phone to scan a QR code associated with some food item
        * see in details all information associated with the product, from the producer and provider till the retail store
    
    ![Local Image](/images/chapter4/12.PNG) 
* In summary
    - actors benefit from a decentralized and trusted information repository
    - IoT devices take advantage of decentralized infrastructure and provide cryptographically signed representation of physical assets
    - smart contracts enable autonomous transactions (e.g., certifications for organic products, alarms in case of cold chain anomalies, ...)
    - consumers benefit from an immutable, transparent history of product

* 3 layer architecture : <ins>**AgriBlockIoT**</ins>
    - M. P. Caro, M. S. Ali, M. Vecchio, R. Giaffreda.  Blockchain-based Traceability in Agri-Food Supply Chain Management: A Practical Implementation.  In Proc. IoT Vertical and Topical Summit for Agriculture.  May 2018.

    ![Local Image](/images/chapter4/13.PNG)

### Chapter 5 Securing Bitcoin

#### High Level Overview

**Bitcoin as a Web Service**

* The server keeps track of a map `(user_id, balance)` and accepts transactions to transfer balance.
    - map $==$ <ins>**ledger**</ins>, which is essentially a record of user balances.
    - the transactions are requests to update the ledger, reflecting the transfer of  funds from the sender's balance to the recipient's balance
* Users interact through a browser (<ins>**wallet**</ins>) to ask for transferring balances.
    - a wallet can be seen in this context as a software application that allows users to manage their Bitcoin addresses and keys, view their balance, and initiate transactions.
* The server is actually a worldwide P2P network fo computers.

**Wallet**

* A wallet might be
    - a desktop wallet
    - a mobile wallet
    - a web wallet
    - a hardware wallet
    - a paper wallet

* Mobile Wallet
    - at first, a bitcoin address is created for you, then transactions to/from that address are tracked
    - the address is seen as an IBAN
    - its creation is a local operation (completely anonymous)

**Address Creation**

* When Alice starts her wallet for the first time :

1. it generates a finite sequence of bits through a secure random generator
    - <ins>**secret private key**</ins>
    - generated through a cryptographically-secure randm generator, otherwise keys might not be random and more easily guessed
2. it computes the bitcoin address as an abstraction of the private key (hashing)
3. it shows the address as an alphanumeric string and as a picture (QRCode)

* The address is not a sensitive piece of information

**Transaction**

* Alice charges her wallet
    - she asks a friend to sell for you bitcoins at your address
    - meets a bitcoin seller in person
    - earns bitcoin by working
    - uses bitcoin at ATM
    - uses bitcoin currency exchange company
* What is the price ?
    - not set by the computer network
    - it is a social agreement (the average of last sell operations)
* The <ins>**charge**</ins> transaction
    - the seller specifies in his wallet Alice's bitcoin address as destination (or scan her QRCode with his mobile phone)
    - the seller signs a transaction with his private key (he acknowledge to send $X$ bitcoins from his address to Alice's address)
    - the seller's wallet broadcasts the signed transaction to one (or more) servers of the bitcoin network
    - the network spread the information (eventually the transaction is cleared, in 10 min or more)
    - Alice's wallet polls the bitcoin network for a transaction having Alice's address as destination and updates the balance on the screen accordingly (confirmation)
* The <ins>**spend**</ins> transaction
* Alice's wallet is now charged and she wants to buy a coffee at Bob's coffee shop
    - Alice's wallet signs, with her private key, a transaction (she acknowledges to send $Y$ bitcoins from her address to Bob's destination address)
    - the transaction is broadcast to one (or more) of the bitcoin network (the transaction is eventually cleared)
    - Alice's wallet polls the bitcoin network for a transaction having her address as source and updates the balance on the scree, accordingly (confirmation)

#### Transactions

**Definition**

* <ins>**Transaction**</ins>
    - data structure that encodes the transfer of values between participants in the Bitcoin system
* Each transaction is a public entry in the bitcoin Blockchain

* Example : view from a block explorer

![Local Image](/images/chapter5/1.PNG)

* Example : a decoded transaction

![Local Image](/images/chapter5/2.PNG)

* Transactions form a chain : output $\rightarrow$ input

![Local Image](/images/chapter5/3.PNG)

**Format**

* Format of a transaction

1. Version
    - the field indicates the version number of the transaction format
    - It allows for updates and changes to the transaction format over time. As for now, the most common version in version 1.
2. Inputs
    - A Bitcoin transaction can have multiple inputs. Each input is a reference to a previous unspent transaction output (UTXO)
    - The counter specifies the number of inputs included in the transaction
    - The inputs list : each input specifies a previous transaction's output and includes :
        * a reference to the previous transaction's hash
        * an index (vout) indicating the specific output in the previous transacttion
        * a scriptSig, which is a script that satisfies the conditions set by the output script of the previous transaction
        * scriptSig is a script that proves the sender has the right to spend the input. It typically contains the sender's public key and a digital signature.
    - Each input is essentially a pointer to a previous transaction's output that the sender owns.
3. Outputs
    - A Bitcoin transaction can have multiple outputs. Each output specifies a destination and the amount of Bitcoin being sent.
    - The outputs list : each output includes :
        * an amount of Bitcoin to be transferred and to whom
        * a scriptPubKey, which is a script setting the conditions that must be met to spend the output in the future. It often includes the recipient's puublic key hash.

![Local Image](/images/chapter5/4.PNG)

* <ins>**Locktime**</ins>
    - the earliest time that a transaction is valid and can be relayed on the network or added to the blockchain
    - this field provides the ability to delay the transaction's inclusion in the Blockchain.
* A transaction can be blockchain settled only if its locktime has been reached
    - locktime $<$ 500,000,000 (block number)
    - locktime $>$ 500,000,000 (unix epoch timestamps)

**Output**

* <ins>**Output**</ins>
    - contains instructions for sending/spending bitcoins
* It contains 3 pieces of information
    - *value*
        * monetary value of the output
        * in satoshis (the smallest bitcoin unit)
    - *locking script length*
        * positive integer
    - *locking script*
        * a script defining the conditions needed to spend the output
        * sometimes called witness script or scriptPubKey
* Example

![Local Image](/images/chapter5/5.PNG)

* Bitcoin full nodes track all available and spendable outputs
    - <ins>**unspent transaction outputs**</ins>
    - UTXO
    - These transaction outputs that have not been sent are available to be used as inputs in new transactions.
* <ins>**UTXO set**</ins>
    - collection of all UTXO
* The UTXO set
    - grows as new UTXO is created
    - shrinks when UTXO us consumed, in other words, when an existing UTXO is used as input in a new transaction, it is removed fromm the UXTO set.
* Example : If Alice receives 1 Bitcoin from Bob in a transaction, that 1 Bitcoin is a UTXO until Alice spends it.
* Validation
    - Nodes validate new transactions by checking that the inputs (UXTOs) are undeed unspent.
    - The nodes reference the UTXO set to verify that the inputs are available and have not been spent in any other transaction.
    - upon validation, the transaction is included in a block.
    - The UXTO is removed from the UXTO set and the transaction is done.

**Input**

* <ins>**Input**</ins>
    - reference to an output from a previous transaction
* It contains 5 pieces of information
    - *outpoint hash*
        * previous transaction containing the spendable output
    - *outpoint index*
        * index within previous transaction's output array to identofy the spendable output
    - *unlocking script length*
        * positive integer
    - *unlocking script*
        * information required to spend the output
        * fulfill the conditions of the UXTO locking script
    - *sequence number*
        * currently disabled

* Example

![Local Image](/images/chapter5/6.PNG)

**Transactions Chain**

![Local Image](/images/chapter5/7.PNG)

* How to generate the first transaction ?
    - <ins>**coinbase transaction**</ins>
        * first transaction in each block
        * brand-new bitcoin payable to the "winning" miner
        * reward for mining
    - The coinbase transaction is the first transaction in each block. It is unique because it creates brand-new Bitcoin that is awarded to the miner who successfully mined the block. It does not have any inputs from previous transactions.
    - This transaction generates new Bitcoin out of nowhere according to the predefined issuance schedule of Bitcoin.
    - It is the mechanism through which new Bitcoin enters circulation.
    - The ammount of Bitcoin generated by the coinbase transaction is known as the block reward.
    - This reward serves as an incentive for miners tp continue validating transactions and securing the network 
* What about transaction fees ?
    - implied (fees are not explicitly stated in a transaction)
    - excess of inputs minus outputs
    - fess = Sum(inputs)-Sum(outputs)
    - collected by the miner as an additional reward for including the transaction in a block.
* Typical transaction
    - pays somebody and gets the change (the input is spent in a single output)
    - aggregate small notes into a larger one (several inputs are aggregated for being spent in a larger output)
    - distribution (a single input is split for being spent in multiple outputs)

#### Bitcoin Address

**Definition**

* <ins>**Bitcoin address**</ins>
    - string of digits and characters that can be shared with anyone who wants to send you money
* Typically, addresses
    - are produced from public keys
        * (private key, public key) generated with elliptic curve algorithm
        * *pubKeyHash*
    - begin with the digit "1"
* Addresses are encoded in Base58

**Base58**

* Encoding numbers with different digit sets

![Local Image](/images/chapter5/8.PNG)

* Conversion of a string to Base58
    - S. Nakamoto, M. Sporny.  The Base58 Encoding Scheme.  Internet Engineering Task Force.  Internet Draft (Work in Progress) draft-msporny-base58-03.  March 2021.

**Address Creation**

* High level overview
    -This process illustrates the process of creating a Bitcoin address from a public key.
    - public key generated from a private key using elliptic curve cryptography.
    - public key is a long alphanumeric string that is derived mathematically from the private key ensuring that private key remains secret and public key can be shared publicly.
    - public key undergoes double hashing to create a more compact and secure identifier.
    - The RIPEMD160 creates a 160 bits, 20 bytes string that is then encoded using Base58. It is a shorter and more readable format.
    - This produces the final Bitcoin address.

    ![Local Image](/images/chapter5/9.PNG)

* A closer look at Base58 encoding step

![Local Image](/images/chapter5/10.PNG)

* Version
    - See [List of address prefixes](https://en.bitcoin.it/wiki/List_of_address_prefixes) for details

    ![Local Image](/images/chapter5/11.PNG)

* Full example

![Local Image](/images/chapter5/12.PNG)

**Motivation**

* Why do we need addresses ?
    - a public key is 64 bytes and not check-summed
    - the address is a 25 bytes (checksum included) representation of the public key
        * more compact
        * more robust thanks to checksum
* For sending and receiving Bitcoins, an address is more convenient than a public key

#### Transactions Validity

**Overview**

* How can we ensure that a transaction is valid ?
    - i.e., how can we match UTXO and input ?
* Both UTXO and input should share something in common such that the transaction can be executed
* Solution
    - every UTXO is locked by a mathematical puzzle
        * locking script
        * <ins>**scriptPubKey**</ins>
    - the corresponding input must provide the solution to the puzzle
        * unlocking script
        * <ins>**scriptSig**</ins>
    - unlocking a UTXO puzzle usually involves a digital signature using the private key related to the address the UXTO is associated to.
* Combining scriptSig and scriptPubKey to evaluate a transaction script
    - most common type of Bitcoin transaction
    - combining means concatenate scriptSig and scriptPubKey prior to script validation
* Example

![Local Image](/images/chapter5/13.PNG)
* Both scriptSig and scriptPubKey are written in SCRIPT
* All nodes validate all transactions before propagating them further
* A transaction is valid if
    - it can be finalized (it is not time locked)
    - its input reference UTXO only
    - each input provides the unlocking solution for the mathematical puzzle of its reference UXTO
    - the amount of the newly generated output(s) is less than or equal to the amount of inputs (transaction fees)

**Bitcoin SCRIPT Language**

* SCRIPT is based on <ins>**reverse-polish notation**</ins> (RPN)
* RPN ?
    - method for representing expressions in which the operator symbol is placed after the arguments being operated on
    - examples
        * $3 \times 5 \rightarrow 3 5 \times$
        * $(3 + 4) \times 5 \rightarrow 3 4 + 5 \times$
    - RPN can be conveniently evaluated using a stack structure
* SCRIPT
    - has no loops or complex flow control capabilities
    - ensures termination (finite time execution and implied by the abive statement)
    - memory access is stack-based (no variables, calculations are performed on the stack)
* SCRIPT is purposely
    - stateless
    - not Turing-complete
* Limited flexibility is a deliberate security feature
    - preventing vulnerability from the transaction validation mechanism
* Goals
    - SCRIPT favors a verification model, not a computation model
        * provability (prove proof in finite time)
        * solvability of the halting problem (impossible for Turing complete)
    - possible to verify arbitrary code execution, without the need for Turing-completeness
        * computational efficiency
            - all nodes will verify the script
            - provide proof, does not require excessive computation
        * soundness
            - keep it simple
            - sophistication must not introduces attack vectors
        * privacy
        * compactness
            * small impact on Blockchains
            * less data also increases efficiency and privacy
* Example : Step by Step Execution
    - Initial Stack
        * The stack is initially empty
    - Push `2`
        * The first element `2` from scriptSig is pushed onto the stack
        * Stack : `[2]`
    - Push `3`
        * from scriptPubKey
        * Stack : `[2, 3]`
    - Operation `OP_ADD`
        * `OP_ADD` pops the top two elements (`3` and `2`) from the stack, adds them together and pushes the result `5` back onto the stack
        * Stack : `[5]`
    - Push `5`
        - Stack : `[5, 5]`
    - Operation `OP_EQUAL`
        - `OP_EQUAL` pops the top two elements from the stack, compares them and pushes `true` or `false` onto the stack if they are equal
    - The stack outputs `true`, verifying that the transaction conditions have been met and the transaction can be spent.


![Local Image](/images/chapter5/14.PNG)

![Local Image](/images/chapter5/15.PNG)

* Interactive SCRIPT playground
    - https://siminchen.github.io/bitcoinIDE/build/editor.html
* Convert SCRIPT to JavaScript
    - https://github.com/charliermarsh/script
* Online IDE
    - https://ide.bitauth.com/
* Operators

![Local Image](/images/chapter5/16.PNG)

**Standard Transaction Script**

* Many different scripts are possible
    - but, for security reasons, relayed only if `IsStandard()`
        * does not violate good network behavior rules
        * its scripts match a small set of believed-to-be-safe templates
* Valid non-standard transactions, if included in blocks, are accepted

* Standard transaction script

1. <ins>**Pay-to-Public Key**</ins> (P2PK)
    - $\textcolor{blue}{scriptSig}$ include the signature
    - $\textcolor{green}{scriptPubKey}$ include the public key

    ![Local Image](/images/chapter5/17.PNG)
2. <ins>**Pay-to-Public-Key-Hash**</ins> (P2PKH)
    - uses addresses instead of public key
    - address is 25 bytes (checksum included), included in the $\textcolor{green}{scriptPubKey}$
    - public keys are revealed at redemption time by the $\textcolor{blue}{scriptSig}$

    ![Local Image](/images/chapter5/18.PNG)
3. <ins>**Null Data**</ins> (`OP_RETURN`)
    - 80 bytes of data are allowed after `OP_RETURN`
    - `OP_RETURN` fores the failure of any script including it
        * the associated transaction output cannot be spent
    - the transaction output is provably unspendable (pruned from the UTXO pool)

    ![Local Image](/images/chapter5/19.PNG)
4. <ins>**Pay-to-Multi-Sig**</ins> (P2MS)
    - multiple agents control coins, in a joint way
    - M signatures out of N possible signers are required to spend the transaction output
        * threshold signature : M-of-N, with M$<$N
        * multisig : N-of-N
    - up to 15-to-15 (1650 bytes signature script limit)
    - problem
        * a multisignature scriptPubKey is bigger than the P2PKH one
        * beneficial for receiver (expensive for the sender in termes of transaction fee)
    
    ![Local Image](/images/chapter5/20.PNG)

* There exist
    - other standard scripts
    - non-standard scripts
    - V. Jacquot, B. Donnet.  CHAUSSETTE: A Symbolic Verification of Bitcoin Scripts.  In Proc. International Workshop on  Cryptocurrencies and Blockchain Technology (CBT).  September 2023.
* No one is forced to use standard transaction scripts
* It is always possible to build your own script ...
    - ... at your own risk

### Chapter 6 Smart Contracts

#### Principle Smart Contract

**Overview**

* Traditional contract

![Local Image](/images/chapter6/1.PNG)

* Smart Contract

![Local Image](/images/chapter6/2.PNG)

* Digital currencies
    - just one Blockchain application

    ![Local Image](/images/chapter6/3.PNG)

* <ins>**Smart contracts**</ins>
    - user-defined programs running on top of a Blockchain

    ![Local Image](/images/chapter6/4.PNG)

* Now
    - Blockchain
        * used to run programs, store information, transfer tokens, ...
        * e.g., <ins>**Ethereum**</ins>
    - tool used is <ins>**smart contracts**<ins>
        * computer programs that use the ledger entries as variables and memory
        * coded in, e.g., <ins>**Solidity**</ins>
    - a transaction is now generalized into a *function call*
    - smart contracts calls are executed according to the ordering within a block
    - ledger update is managed via a virtual machine
        * generalize the simple ledger to a *state machine*
        * a run-time environment for smart contract execution
        * <ins>**Ethereum Virtual Machine**</ins> (EVM)

**Web 2.0 vs Web 3.0**

* Web 2.0 : System view

![Local Image](/images/chapter6/5.PNG)

* Web 3.0 : System view

1. Browser
    - The user's entry point to interact with decentralized applications <ins>**dApps**</ins>. In Web 3.0, browsers can integrate with wallets and interact with Blockchain-based applications directly.
2. Wallet
    - An essential component for Web 3.0, wallets store users' private keys and manage their cryptocurrency transactions.
    - Wallets allow users to interact with dApps by providing authentication and transaction capabilities
3. Front-End (HTML/JS/CSS)
    - The user interface of the dApp, built using traditional web technologies such as HTML, JavaScript, etc.
    - This layer interacts with the user's browser and provides a seamless user experience for interacting with the dApp
4. Node Provider
    - Node providers offer infrastructure to connect to the Blockchain without requiring users to run their own full nodes
    - They act as intermediaries that facilitate communication between the front-end and the Blockchain
5. Smart Contracts (Solidity/Vyper for Ethereum)
    - The core of the dApp's logic is implemented as a smart contract, which is a self-executing contract with the terms of the agreement directly written into code
    - These contracts run on the Ethereum Virtual Machine (EVM), which ensures they execute as programmed without downtime, fraud, or third-party interference
6. Blockchain (Ehtereum/Polygon)
    - The decentralized ledger that records all transactions and smart contract executions
    - Ethereum and Polygon are examples of Blockchains that support smart contracts and dApps
    - The Blockchain ensures transparency, security and immutability of data

<ins>**dApps**</ins> are applications that run on a decentralized network, typically a Blockchain instead of a single centralized server. They leverage the principles of decentralization, cryptographic security and consensus mechanisms to operate.

Users access the dApp through a browser or mobile app. They authenticate themselves using a digital wallet.

When a user performs an action in the dApp (e.g., transferring tokens, voting, or interacting with a service), the front-end sends a transaction request to the smart contract.

The transaction is sent to the Blockchain, where the smart contract is executed. This execution is validated and recorded by the nodes (miners/validators) in the Blockchain network.

Once the transaction is confirmed by the network, the result is recorded on the Blockchain. This ensures that the transaction is immutable and transparent.

The front-end retrieves the transaction result from the Blockchain (via a node provider) and updtes the user interface to reflect the change.

![Local Image](/images/chapter6/6.PNG)

**Generalities**

* Smart contract typical lifecycle
    - deployed by a transaction
    - establish initial states (immutable once deployed)
    - store states and execute computations
* Where is the program stored ?
    - writing a program
        * high-level language (e.g., Solidity, Viper, ...)
    - program is compiled
        * into low-level language the Blockchain state machines can understand
    - program is deployed
        * binary is stored in the state of the Blockchain
    - The state machine in a blockchain is collectively maintained by all participating nodes in the network. No single entity owns it, rather, it operates based on a decentralized consensus mechanism.
* What kind of programming language should be used ?
    - should be similar to existing languages syntax
    - should have additional functionalities to access Blockchain state
    - any execution should yield the same result
        * execution output can be verified by everyone else
        * `rand()` not allowed
        * functions calls to outside (e.g., the Internet) are not allowed
    - cost of execution should be readily calculated
        * <ins>**gas**</ins> fee
        * required to successfully conduct a transaction or execute a contract on Ethereum

#### Ethereum

**Overview**

* Ethereum
    - cryptocurrency (ether `ETH`)
    - runs the Ethereum protocol
    - permissionless Blockchain capable of executing smart contracts
        * executed when triggered by a transaction from a user
* Interacting with Ethereum
    
![Local Image](/images/chapter6/7.PNG)

* An Ethereum client allows you to run an Ethereum Node on your computer
* An Ethereum client can
    - create accounts and contracts
    - sending `ETH` to other accounts
    - sending transactions to contracts
    - mining on Ethereum network
    - ...

**EVM**

* <ins>**Ethereum Virtual Machine**</ins> (EVM)
    - distributed execution environment (*state machine*)
    - running on the Ethereum Blockchain
* Each block on Ethereum changes the state of the EVM
* Every Ethereum user sees the same canonical EVM state at any given block
* State of EVM
    - State ($\sigma_{t}$ and $\sigma_{t+1}$)
        * This represents the state of the Ethereum Blockchain at time t before the transaction is processed and at time t + 1, after the transaction is processed.
    - Account state : each account in Ethereum has an associated state, which includes the balance, nonce ( a counter used to prevent replay attacks), storage, and the contract code (if it's a smart contract account)
    - Code : the executable code associated with the account. For a smart contract, this is the code that gets executed when a transaction is sent to this account.
    - Storage : The persistent storage of the account, used by smart contracts to store data.
    - Input data : the data sent along with a transaction. For smart contracts, this data often includes the function to be executed and the parameters for that function.

![Local Image](/images/chapter6/8.PNG)

* A zoom in the EVM
    - Machine State (Volatile)
        * The machine state in the EVM is volatile, meaning it exists only during the execution of a transaction and does not persist across transactions.
    - Program Counter
        * This is a pointer that indicates the current position in the EVM code being executed. It keeps track of which instruction is currently being processed.
    - Gas Available
        * Gas is the unit computational effort required to execute operations in the EVM. The gas available indicates how much gas remains for the execution of the transaction. Each operation costs a certain amount of gas, and if the gas runs out, the transaction fails.
    - Stack
        * The stack is used for holding temporary values during execution. The EVM operates in a stack-based manner, meaning that most instructions push values to the stack or pop values from it.
        * Memory in the EVM is a temporary space used for storing data during execution. It is cleared after the transaction completes.
    - EVM Code
        * This is the bytecode of the smart contract being executed. The EVM executes this code line by line, with each line representing an operation.
    - Account Storage
        * Storage is a persistent key-vallue store associated with an Ethereum account.

![Local Image](/images/chapter6/9.PNG)

* <ins>**Stack**</ins>
    - Last-In-First-Out principle
        * LIFO
    - stack item unit size is 256 bits (32 bytes)
    - stack maximum capacity is 1024 units
    - operations insert/removes items to/from the stack
    - volatile (deleted after execution)
* <ins>**Memory**</ins>
    - array of bytes (item size is 1 byte)
    - addressed by an U256
    - operations read/write the memory
    - volatile (deleted after execution)
* <ins>**Storage**</ins>
    - (key, value) storage (both 32 bytes)
    - operations read/write the storage
    - persistent (maintained in a hash accumulator, often referred to as a Merkle Patricia Trie which combines the Merkle Tree and the Patricia Trie, practical algorithm to retrieve information coded in alphanumeric)
    - the hash accumulator refers to the Merkle root which is a single hash that represents the entire structure of the trie.
    - When a smart contract stores data in the EVM, each key-value pair is stored in the contract' storage trie. The storage trie is updated, and its root hash changes. The new root hash of the storage trie is then stored in the account's node in the state trie. The state trie is updated, and its root hash changes, resulting in a new state root for the Blockchain.

    ![Local Image](/images/chapter6/10.PNG)

A Trie (pronounced "try") is a type of search tree‚Äîa data structure used for locating specific keys from within a set. These keys are usually strings. The name "Trie" comes from the word "retrieval."

Trie is a tree-like data structure that stores strings and supports efficient string search, insertion, and prefix querying.
Each node in a Trie represents a character of a key, and each path represents a key.
Tries are particularly useful for applications involving a large set of strings, such as autocomplete, spell checking, IP routing, and genome analysis.

#### Solidity

**Overview**

* <ins>**Solidity**</ins>
    - https://soliditylang.org/
* High level language for implementing smart contracts
    - statically typed
    - supports inheritance
    - librairies
    - complex user-defined types
    - syntax influenced by Javascript and C++
    - online editor
        * https://remix.ethereum.org/
        * compile, emulate, deploy contracts
* Compiler
    - `solc`, source code to byte code
    - command-line tool
* Interaction with EVM

![Local Image](/images/chapter6/11.PNG)

![Local Image](/images/chapter6/12.PNG)

**Basic Structure**

* Storage example

![Local Image](/images/chapter6/13.PNG)

**State Variables**

* Value types
    - boolean (`bool`)
    - integer (`int`, `uint`, `uint8`, `uint256`)
    - 20-bye value as an address (`address`)
    - fixed-size byte array (`bytes[1-32]`, `byte1`, `byte2`, ..., `byte32`)

* Reference type

![Local Image](/images/chapter6/14.PNG)

**EVM Data Store**

* State variables (storage)
* Function arguments (memory)
* Local variables of reference types
    - in memory or storage
    - needs to be stated exlicitly when declaring the variable
* Local variables of value types (reside on stack)

![Local Image](/images/chapter6/15.PNG)

![Local Image](/images/chapter6/16.PNG)

* What is `asset[0].name` ?
    - Storage : persistent storage, data stored here remains on the Blockchain
    - Memory : temporary storage, data stored here is not persistent and only exists for the duration of the function call
    - Since memory is temporary, changes made here do not persist outside the function call so `asset[0].name` will `new_name_1` in the storage. Memory did only a temporary copy of the array.

**Contract Methods**

* Syntax

![Local Image](/images/chapter6/17.PNG)

* Example

![Local Image](/images/chapter6/18.PNG)

**Visibility**

* State variables visibility
    - `public`
        * allows other contract to read their values
    - `internal`
        * can only be accessed by the defined/derived contracts
    - `private`
        * can only be accessed by the defined contract
* Function visibility
    - `external`
        * can only be called from other contracts and via transactions
    - `internal`
        * can only be accessed by the defined/derived contracts
    - `public`
        * `external` + `internal`
    - `private`
        * can only be accessed by the defined contract

**Mutability**

* `view` functions
    - cannot modify states or call other non `view` functions
    - see `getUsingStorage()`
* `pure` functions
    - cannot read or modify states or call non pure functions
    - see `setNameUsingMemory()`

**Payable**

* A function can
    - receive ETH
    - use the value of ETH in its internal calculations

    ![Local Image](/images/chapter6/19.PNG)

**Abstract Contract**

* `virtual`
    - allows inherited contracts to modify the function behavior
* `override`
    - modifies the inherited function

    ![Local Image](/images/chapter6/20.PNG)

**Methods Call**

* How to call methods from other contracts ?

![Local Image](/images/chapter6/21.PNG)

#### Attacks

**Underflow/Overflow**

* Similar to traditional underflow/overflow attacks

* Applied to `uint` type
    - can be underflowed or overflowed to reach unintended conclusions or chunks of code

* Overflow

![Local Image](/images/chapter6/22.PNG)

* Underflow

![Local Image](/images/chapter6/23.PNG)

* Example

![Local Image](/images/chapter6/24.PNG)

Yes, the `lockTime` variable in the `TimeLock` contract can be instrumented to overflow, which would allow a user to withdraw their funds prematurely.

In Solodity, the `uint` type is an alias for `uint256`, which is an unsigned 256-bit integer. This means that it can hold values from `0` to `2^256 - 1`. When the value exceeds `2^256 - 1`, it wraps around to `0` (integer overflow).

First, a user deposits funds into the contract, which sets their initial ``lockTime` to the current timestamp plus one week.

The user then calls the `increaseLockTime` function with a large enough value to cause an overflow. For example, if the current `lockTime` is close to `2^256 - 1`, adding any positive value will cause it to wrap around to a small value.

After the overflow, the user can call the `withdraw` function. Due to the overflow, the condition `require(block.timestamp > lockTime[msg.sender], "Locktime not expired");` will be bypassed because `lockTime[msg.sender]` will now be a small value.

* Which value should we use to overflow `lockTime` ?

* If `t` = current lock time, then we need to find $x$ such that
    - $x + t = 2^{256} = 0$
    - $x = -t$
    - $2^{256} = type(unit).max + 1$
    - $x = type(uint.max) + 1 - t$

* Code for the attack

![Local Image](/images/chapter6/25.PNG)

* How to protect ?
    - use Solidity compiler $\geq$ 0.8

* Compiler uses symbolic execution to detect underflow/overflow (error generated in case)

**Reentrancy**

* Vulnerability occurs when
    - a contract interacts with an external contract
    - before modifying itw own local state variables
* Can sometimes be taken advantage of
    - by placing a malicious `fallback()` function in the receiving contract
* Known as <ins>**reentrancy attack**</ins>
    - F. Richter Vidal, N. Ivaki, N. Laranjeiro.  OpenSCV: An Open Hierarchical Taxonomy for Smart Contract Vulnerabilities.  arXiv cs.CR 2303.14253.  March 2023.

* Attack Illustration

![Local Image](/images/chapter6/26.PNG)

* Victim Contract
    - The `deposit` function allows users to deposit ETH and updates their balance
    - The `withdraw` function allows users to withdraw their deposited ETH. However, it updates the balance after sending ETH, making it vulnerable to reentrancy attacks.
    - The `getBalance` function returns the contract's balance.

![Local Image](/images/chapter6/27.PNG)

* Attacker Contract
    - The `Attack` contract interacts with the `EtherStore` contract.
    - The `constructor` initializes the `etherStore` variable with the address of the `EtherStore` contract.
    - The `attack` function initiates the attack by depositing 1 ETH and then calling the `withdraw` function.
    - The `fallback` function is called when the `EtherStore` contract sends ETH back to the `Attack` contract. It re-invokes the `withdraw` function, causing the reentrancy loop.
    - The `getBalance` function returns the balance of the `Attack` contract.

![Local Image](/images/chapter6/28.PNG)

The reentrancy attack allows an attacker to drain the funds from a vulnerable contract by recursively calling the withdraw function before the original call completes its execution. This is due to the order of operations in the victim contract, where the balance is updated after the withdrawal, allowing multiple withdrawals with a single deposit.

**Additional Attacks**

* For additional attacks, see
    - N. Atzei, M. Bartoletti, T. Cimoli.  A Survey of Attacks on Ethereum Smart Contracts.  In Proc. International Conference on Principles of Security and Trust.  April 2017.
    - N. Sharma, S. Sharma, A. Sindgi.  Solidity Smart Contract Vulnerabilities, Attack Scenarios, and Mitigation - A Survey.  In Proc. International Conference on Communication and Computational Technologies (ICCCT).  January 2023
    - H. Chu, P. Zhang, H. Dong, Y. Xiao, S. Jo, W. Li.  A Survey on Smart Contract Vulnerabilities: Data Sources, Detection, and Repair.  In Information and Software Technology. 159(C).  July 2023.
    - G. Sun, C. Jiang, J. Shebn, Y. Zhang.  Smart Contract Vulnerability Detection Methods: A Survey.  In Proc. International Conference on Blockchain and Trustworthy System (BlockSys).  August 2023.
    - N. Ivanov, C. Li, Q. Yan, Z. Sun, Z. Cao, X. Luo.  Security Threat Mitigation for Smart Contracts: A Comprehensive Survey.  In ACM Computing Surveys.  55(14), pg. 1-37.  December 2023